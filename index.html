<!DOCTYPE HTML>
<html lang='en'>
	<head>
		<meta charset='utf-8'>
		<title>Blockchain Simulator</title>
		<meta name='author' content='Simeon Wuthier'>
		<meta name='description' content='A proof-of-work network simulator for blockchain and cryptocurrency research.'>
		<meta name='keywords' content='blockchain, bitcoin, proof of work, pow, network, simulator, simulation, blockchain, cryptocurrency, research, peer to peer, p2p'>
		<meta name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no'>
		<link rel='shortcut icon' href='img/favicon.ico' type='image/x-icon'>
		<link rel='icon' href='img/favicon.ico' type='image/x-icon'>
		<link rel='stylesheet' href='lib/bootstrap.min.css'>
		<link href='lib/jsoneditor.min.css' rel='stylesheet' type='text/css'>
		<script type='text/javascript' src='lib/vis-network.min.js'></script>
		<script src='lib/jsoneditor.min.js'></script>
		<script src='lib/lz-string.min.js'></script>
		<link rel="stylesheet" href="lib/codemirror/lint.css">
		<link rel='stylesheet' href='lib/codemirror/codemirror.css'>
		<link rel='stylesheet' href='lib/codemirror/material-darker.css'>
		<link rel='stylesheet' href='style.css'>
		<script src='lib/codemirror/codemirror.js'></script>
		<script src='lib/codemirror/formatting.js'></script>
		<script src='lib/codemirror/javascript.js'></script>
		<script src="lib/codemirror/jshint.js"></script>
		<script src="lib/codemirror/lint.js"></script>
		<script src="lib/codemirror/javascript-lint.js"></script>
		<script src="lib/NoSleep.min.js"></script>
		<style id='miner-colors-selector'></style>
	</head>

<body class='py-3'>
	<div class='container bg-light rounded pb-3'>
		<div class='py-2 text-center'>
			<h1 class='display-4 d-inline'>Blockchain Simulator</h1> <span class='badge badge-primary'>v1.0</span> <span class='badge badge-secondary'><a class='text-white' href='index_v0.12.html'>v0.12 can be found here</a></span>
		</div>
		<div class='jumbotron p-3 mb-3'>
			<div class='row'>
				<div class='col-md-12 mb-3'>
					<div class='btn-group fillx' style='max-height:35px;cursor:pointer'>
						<div class='btn-group w-100'>

							<!-- File Options Dropdown -->
							<button type='button' class='btn btn-dark dropdown-toggle dropdown-toggle-split rounded-0' data-toggle='dropdown' aria-haspopup='true' aria-expanded='false' onclick='DOM_clearOptionMsg()'>
								<span class='sr-only'>Toggle Dropdown</span>
								<span id='fileOptionMsg' class='badge badge-light'></span>
								File
							</button>
							<div class='dropdown-menu'>
								<a class='dropdown-item' onclick='loadFromFile()'>Open network file<span class='badge badge-secondary float-right' style='margin-top:3px'>CTRL+O</span></a>
								<a class='dropdown-item' onclick='saveToFile(true)'>Save network file <span class='badge badge-secondary float-right' style='margin-top:3px'>CTRL+S</span></a>
								<a class='dropdown-item' onclick='saveToFile(false)'>Save network file (uncompressed)</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' onclick='saveLocalStorage()'>Save network to LocalStorage</a>
								<a class='dropdown-item' onclick='loadLocalStorage()'>Load network from LocalStorage</a>
								<a class='dropdown-item' onclick='deleteLocalStorage()'>Delete network from LocalStorage</a>
								<a class='dropdown-item' onclick='clearAllLocalStorage()'>Clear LocalStorage</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' data-toggle='modal' data-target='#copyToClipboardModal' onclick='DOM_saveToClipboard()'>Copy network to clipboard</a>
								<a class='dropdown-item' data-toggle='modal' data-target='#loadFromClipboardModal' onclick='DOM_loadFromClipboard()'>Load network from clipboard</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' href='https://github.com/simewu/blockchain-simulator' target='_blank'>View on GitHub</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' data-toggle='modal' data-target='#aboutModal' onclick='loadAboutModal()'>About</a>
							</div>
						</div>
						<div class='btn-group w-100' style='max-height:35px;cursor:pointer'>

							<!-- Network Options Dropdown -->
							<button type='button' class='btn btn-dark dropdown-toggle dropdown-toggle-split rounded-0' data-toggle='dropdown' aria-haspopup='true' aria-expanded='false' onclick='DOM_clearOptionMsg()'>
								<span class='sr-only'>Toggle Dropdown</span>
								<span id='networkOptionMsg' class='badge badge-light'></span>
								Network
							</button>
							<div class='dropdown-menu'>
								<a class='dropdown-item' data-toggle='modal' data-target='#addMinerModal' onclick='addMinerBtnClicked()'><b>Add/edit miner</b></a>
								<a id='removeMinerBtn' class='dropdown-item' onclick='DOM_removeMiner()'>Remove miner</a>
								<a class='dropdown-item' onclick='if(confirm("You are about to remove all miners.")) DOM_removeAllMiners()'>Remove all miners</a>
								<a class='dropdown-item' onclick='DOM_sortMiners()'>Sort miners</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' onclick='DOM_globalSetPower()'>Globally set power (hashes/s)</a>
								<a class='dropdown-item' onclick='DOM_globalSetLatency()'>Globally set latency (ms)</a>
								<a class='dropdown-item' onclick='DOM_globalSetDownloadMBPS()'>Globally set downlink bandwidth (MBps)</a>
								<a class='dropdown-item' onclick='DOM_globalSetUploadMBPS()'>Globally set uplink bandwidth (MBps)</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' onclick='DOM_toggleLoggingNetworkData()' id='DOM_item_toggleLoggingNetworkData'>Enable logging network<br>data within each miner</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' onclick='DOM_clearBlockchain()'>Clear all blockchains</a>
								<a class='dropdown-item' onclick='DOM_setNetworkDifficulty()'>Set network difficulty</a>
								<a class='dropdown-item' onclick='DOM_setBlockSizes()'>Set block sizes</a>
								<a class='dropdown-item' onclick='toggleSha256()' id='useSHA256Btn'>Use secure SHA-256 (slower)</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' data-toggle='modal' data-target='#viewNetworkModal' onclick='DOM_viewNetworkJSON()'>View full network structure</a>
							</div>
						</div>
						<div class='btn-group w-100' style='max-height:35px;cursor:pointer'>

							<!-- Topology Options Dropdown -->
							<button type='button' class='btn btn-dark dropdown-toggle dropdown-toggle-split rounded-0' data-toggle='dropdown' aria-haspopup='true' aria-expanded='false' onclick='DOM_clearOptionMsg()'>
								<span class='sr-only'>Toggle Dropdown</span>
								<span id='topologyOptionMsg' class='badge badge-light'></span>
								Topology
							</button>
							<div class='dropdown-menu'>
								<a class='dropdown-item' data-toggle='modal' data-target='#generateTopologyModal'><b>Generate a topology</b></a>
								<a class='dropdown-item' onclick='duplicateTopology()'>Duplicate current topology</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' onclick='bidirectionallyConnectPeers()'>Connect nodes bidirectionally</a>
								<a class='dropdown-item' onclick='fullyConnectPeers()'>Connect all nodes</a>
								<a class='dropdown-item' onclick='fullyDisconnectPeers()'>Disconnect all nodes</a>
							</div>
						</div>

						<div class='btn-group w-100' style='max-height:35px;cursor:pointer'>

							<!-- Display Options Dropdown -->
							<button type='button' class='btn btn-dark dropdown-toggle dropdown-toggle-split rounded-0' data-toggle='dropdown' aria-haspopup='true' aria-expanded='false' onclick='DOM_clearOptionMsg()'>
								<span class='sr-only'>Toggle Dropdown</span>
								<span id='displayOptionMsg' class='badge badge-light'></span>
								Display
							</button>
							<div class='dropdown-menu'>
								<a class='dropdown-item' onclick='toggleVisualizations()'>Toggle visualizations</a>
								<a class='dropdown-item' onclick='DOM_toggleMinerStatsTable()'>Toggle miner stats table</a>
								<a class='dropdown-item' onclick='DOM_toggleSamplerForm()'>Toggle sampler</a>
								<div class='dropdown-divider' id='vis_btn_delimeter' ></div>
								<a class='dropdown-item' id='vis_refresh_btn' onclick='DOM_refreshVisualizer()'>Refresh visualizer</a>
								<a class='dropdown-item' id='vis_physics_btn' onclick='DOM_togglePhysics()'>Disable visualizer physics</a>
								<a class='dropdown-item' id='vis_line_length_btn' onclick='DOM_setLineLengths()'>Set line lengths</a>
								<a class='dropdown-item' id='vis_line_length_btn' onclick='DOM_setBarWidths()'>Set bar widths</a>
								<div class='dropdown-divider'></div>
								<a class='dropdown-item' onclick='formatSamplerCode()'>Format all sampler code</a>
							</div>
						</div>

					</div>
				</div>
				<hr>
			</div>
			<div class='row'>
				<div class='col-md-4'>
					<div class='row px-3' style='height:calc(100% - 35px)'>
						<select id='minerList' onclick='DOM_selectedMiner()' onchange='DOM_selectedMiner()' size='6' class='form-control fillx filly'>
						</select>
					</div>

					<div class='btn-group fillx' style='max-height:35px;cursor:pointer;padding:0 1px'>
						<button id='toggleMiningBtn' onclick='DOM_toggleAllMining()' type='button' class='btn btn-dark rounded-0' style='width:100%'>Start All Miners</button>

						<!-- Miner Options -->
						<button type='button' class='btn btn-dark rounded-0 dropdown-toggle dropdown-toggle-split' data-toggle='dropdown' aria-haspopup='true' aria-expanded='false' onclick='DOM_clearOptionMsg()'>
							<span class='sr-only'>Toggle Dropdown</span>
						</button>
						<div class='dropdown-menu'>
							<a id='toggleMinerMiningBtn' class='dropdown-item' onclick='DOM_toggleMining()'>Toggle mining for miner</a>
							<a id='clearMinerBlockchainBtn' class='dropdown-item' onclick='DOM_clearMinerBlockchain()'>Clear blockchain for miner</a>

							<div class='dropdown-divider'></div>
							<a id='stopBlocksInFlightBtn' class='dropdown-item' onclick='DOM_toggleStoppingBlocksInFlight()'>Stop blocks in flight<br>after stopping all miners</a>
						</div>
					</div>
				</div>
				<div class='col-md-8'>
					<div class='row pr-3'>
						<div id='jsoneditor'></div>
						<span id='editMinerBadge' class='ml-auto badge badge-secondary'></span>
					</div>
				</div>
			</div>	
		</div>
		<div class='row'>
			<div class='col-md-12'>
				<div id='networkVisualizer'></div>
			</div>
		</div>
		<div class='row'>
			<div id='canvasVisualizerContainer' class='col-md-12'>
				<div id='canvasVisualizerCodeContainer' class='col-md-12 m-0'>
					<label id='canvasVisualizerCodeLabel' for='canvasVisualizerCode'>Time Plot:</label>
					<input id='canvasVisualizerCode' list='canvasVisualizerCodeList' type='text' onchange='saveSamplerSettings()' class='col-sm-6 custom-select custom-select-sm'>
					<datalist id='canvasVisualizerCodeList'>
					    <option value='miner.lastAcceptedBlock'>Visualize most recent block</option>
					    <option value='miner.lastAcceptedBlock.balances[miner.ID] * 700'>Visualize account balance</option>
					    <option value='miner.lastAcceptedBlock.height * 700'>Visualize block height</option>
					    <option value='miner.networkBuffer.buffer'>Visualize network buffers</option>
					    <option value='miner.blockchain_blockDelay[miner.blockchain_blockDelay.length - 1] * 10'>Visualize block propagation time (requires toggling network logging)</option>
					    <option value='Math.random()'>Random noise</option>
					</datalist>
				</div>
				<canvas id='canvasVisualizer' onclick='canvasVisualizerClicked(event)' class='w-100' height='9'></canvas>
			</div>
		</div>
		<div id='minerStatsDiv' class='row'>
			<div class='col-md-12'>
				<small>
					<table id='minerStatsTable' class='table table-dark table-hover table-responsive table-sm mb-0'>
					</table>
				</small>
			</div>
		</div>
		<div id='samplerDiv' class='row'>
			<div class='col-md-12'>
				<div class='card text-white bg-dark rounded-0 px-2'>
					<div class='card-header'>
						<br>
						<div class='form-group row'>
							<div class='input-group'>
								<label for='timePerSample' class='col-sm-3 col-form-label'>Time per sample (s)</label>
								<div class='col-sm-9 p-0'>
									<input  id='timePerSample' type='number' onchange='saveSamplerSettings()' class='form-control border border-secondary' min='0' value='60' required>
								</div>
							</div>
						</div>
						<div class='form-group row'>
							<label for='codeBeforeSampling' class='col-sm-3 col-form-label'>Run before sampling</label>
							<div class='col-sm-9 p-0'>
								<textarea id='codeBeforeSampling' class='form-control text-white bg-dark border border-secondary' rows='1'></textarea>
							</div>
						</div>
						<div class='form-group row'>
							<label for='codeBetweenSamples' class='col-sm-3 col-form-label'>Run between samples</label>
							<div class='col-sm-9 p-0'>
								<textarea id='codeBetweenSamples' class='form-control text-white bg-dark border border-secondary' rows='2'></textarea>
							</div>
						</div>
						<div class='form-group row'>
							<label for='codeAfterSampling' class='col-sm-3 col-form-label'>Run after sampling</label>
							<div class='col-sm-9 p-0'>
								<textarea id='codeAfterSampling' class='form-control text-white bg-dark border border-secondary' rows='1'></textarea>
							</div>
						</div>
						<div class='form-group row'>
							<label class='col-sm-3 col-form-label'></label>
							<div class='col-sm-9 p-0'>
								<label class='btn btn-secondary'>
									<input id='logSamplesCheckbox' type='checkbox' onchange='saveSamplerSettings()'> Log samples to file
								</label>
								<label class='btn btn-secondary'>
									<input id='resetBlockchainAfterEachSampleCheckbox' type='checkbox' onchange='saveSamplerSettings()' checked> Reset blockchain after each sample
								</label>
								<label class='btn btn-secondary'>
									<input id='updateTableAfterEachSampleCheckbox' type='checkbox' onchange='saveSamplerSettings()' checked> Update table
								</label>
							</div>
						</div>
						<div id='logColumns' class='form-group row'>
							<label class='col-sm-3 col-form-label'>Log columns (multiselect)</label>
							<div class='col-sm-9 p-0'>
								<select id='logColumnsList' multiple='multiple' onchange='saveSamplerSettings()' class='form-control' size='8'>
								</select>
							</div>
						</div>
						<div class='form-group row mb-0'>
							<button id='toggleSamplingBtn' class='btn btn-primary fillx border border-dark' onclick='toggleSampling()'>Begin Sampling</button>
						</div>
					</div>

					<div class='col-md-12 p-2'>
						<small>
							<table id='sampleTable' class='table table-dark table-hover table-responsive table-sm mb-2'>
							</table>
						</small>
					</div>
				</div>
			</div>
		</div>

		<!-- Modals -->
		<div class='modal fade' id='addMinerModal' role='dialog'>
			<div class='modal-dialog'>
				<!-- Modal content-->
				<div class='modal-content'>
					<div class='modal-header'>
						<h4 class='modal-title'>Add or Edit a Miner</h4>
						<button type='button' class='close' data-dismiss='modal'>&times;</button>
					</div>
					<form>
						<div class='modal-body'>
							<div class='form-group row'>
								<label for='addMinerName' class='col-sm-4 col-form-label'>Name</label>
								<div class='col-sm-8'>
									<input type='text' class='form-control' id='addMinerName' value='' onclick='this.select()' onblur='this.value = fixCase(this.value)' required>
								</div>
							</div>
							<div class='form-group row'>
								<label for='addMinerPower' class='col-sm-4 col-form-label'>Computing Power</label>
								<div class='col-sm-8'>
									<input type='number' class='form-control' id='addMinerPower' min='0' value='10' required>
								</div>
							</div>
							<div class='form-group row'>
								<label for='addMinerLatency' class='col-sm-4 col-form-label'>Network Latency (milliseconds)</label>
								<div class='col-sm-8'>
									<input type='number' class='form-control' id='addMinerLatency' min='0' value='10' required>
								</div>
							</div>
							<div class='form-group row'>
								<label for='addMinerDownloadMBPS' class='col-sm-4 col-form-label'>Network Downlink (MB per second)</label>
								<div class='col-sm-8'>
									<input type='number' class='form-control' id='addMinerDownloadMBPS' min='0' value='10' required>
								</div>
							</div>
							<div class='form-group row'>
								<label for='addMinerUploadMBPS' class='col-sm-4 col-form-label'>Network Uplink (MB per second)</label>
								<div class='col-sm-8'>
									<input type='number' class='form-control' id='addMinerUploadMBPS' min='0' value='10' required>
								</div>
							</div>
							<div class='form-group row'>
								<label for='multiselectAddPeers' class='col-sm-4 col-form-label'>Peers (multiselect)</label>
								<div class='col-sm-8'>
									<select id='multiselectAddPeers' multiple='multiple' class='form-control' size='6'>
									</select>
								</div>
							</div>
						</div>
						<div class='modal-footer'>
							<button id='addMinerSubmit' class='btn btn-default' onclick='DOM_addMiner()' data-dismiss='modal'>Add/Edit</button>
						</div>
					</form>
				</div>
			</div>
		</div>
		<div class='modal fade' id='generateTopologyModal' role='dialog'>
			<div class='modal-dialog'>
				<!-- Modal content-->
				<div class='modal-content'>
					<div class='modal-header'>
						<h4 class='modal-title'>Pick a Topology</h4>
						<button type='button' class='close' data-dismiss='modal'>&times;</button>
					</div>
					<div class='modal-body'>
						<img src='img/topologies.png' style='width:100%' usemap='#topologies'>
						<map id='topologyMap' name='topologies' data-dismiss='modal'  data-toggle='modal' data-target='#generateTopologyModal2'>
							<area shape='rect' coords='10, 10, 450, 506' alt='Ring' onclick='DOM_selectTopology("Ring")'>
							<area shape='rect' coords='471, 10, 1005, 506' alt='Mesh' onclick='DOM_selectTopology("Mesh")'>
							<area shape='rect' coords='1026, 10, 1403, 506' alt='Star' onclick='DOM_selectTopology("Star")'>
							<area shape='rect' coords='1424, 10, 1910, 506' alt='Fully Connected' onclick='DOM_selectTopology("Fully Connected")'>
							<area shape='rect' coords='10, 527, 740, 931' alt='Line' onclick='DOM_selectTopology("Line")'>
							<area shape='rect' coords='761, 527, 1367, 931' alt='Tree' onclick='DOM_selectTopology("Tree")'>
							<area shape='rect' coords='1388, 527, 1910, 931' alt='Bus' onclick='DOM_selectTopology("Bus")'>
							<area shape='rect' coords='10, 958, 955, 1412' alt='Barabási-Albert' onclick='DOM_selectTopology("Barabási-Albert")'>
							<area shape='rect' coords='965, 958, 1910, 1412' alt='Bitcoin' onclick='DOM_selectTopology("Bitcoin")'>
						</map>
					</div>
				</div>
			</div>
		</div>
		<div class='modal fade' id='generateTopologyModal2' role='dialog'>
			<div class='modal-dialog'>
				<!-- Modal content-->
				<div class='modal-content'>
					<div class='modal-header'>
						<h4 id='topologyTitle' class='modal-title'>Topology</h4>
						<button type='button' class='close' data-dismiss='modal'>&times;</button>
					</div>
					<form>
						<div class='modal-body'>
							<div id='topologyjsoneditor'></div>
						</div>
						<div class='modal-footer'>
							<button class='btn btn-default' onclick='DOM_generateTopology()' data-dismiss='modal'>Generate</button>
						</div>
					</form>
				</div>
			</div>
		</div>
		<div class='modal fade' id='viewNetworkModal' role='dialog'>
			<div class='modal-dialog'>
				<!-- Modal content-->
				<div class='modal-content'>
					<div class='modal-header'>
						<h4 id='topologyTitle' class='modal-title'>View Network</h4>
						<button type='button' class='close' data-dismiss='modal'>&times;</button>
					</div>
					<div class='modal-body'>
						<div id='networkjsoneditor'></div>
						<span id='editNetworkBadge' class='ml-auto badge badge-secondary'></span>
					</div>
				</div>
			</div>
		</div>
		<div class='modal fade' id='copyToClipboardModal' role='dialog'>
			<div class='modal-dialog'>
				<!-- Modal content-->
				<div class='modal-content'>
					<div class='modal-header'>
						<h4 id='topologyTitle' class='modal-title'>Copy Compressed Network</h4>
						<button type='button' class='close' data-dismiss='modal'>&times;</button>
					</div>
					<div class='modal-body'>
						<textarea id='copyToClipboardTextarea' style='width:100%;height:400px' readonly></textarea>
						<button class='btn btn-dark fillx' onclick='DOM_copyToClipboardButton()' data-dismiss='modal'>Copy</button>
					</div>
				</div>
			</div>
		</div>
		<div class='modal fade' id='loadFromClipboardModal' role='dialog'>
			<div class='modal-dialog'>
				<!-- Modal content-->
				<div class='modal-content'>
					<div class='modal-header'>
						<h4 id='topologyTitle' class='modal-title'>Paste Network</h4>
						<button type='button' class='close' data-dismiss='modal'>&times;</button>
					</div>
					<div class='modal-body'>
						<p>Compressed and uncompressed (JSON) strings are supported.</p>
						<textarea id='pasteNetworkTextarea' style='width:100%;height:400px'></textarea>
						<button id='loadPastedNetworkBtn' class='btn btn-dark fillx' onclick='DOM_loadPastedNetwork()' data-dismiss='modal'>Load network</button>
					</div>
				</div>
			</div>
		</div>
		<div class='modal fade' id='aboutModal' role='dialog'>
			<div class='modal-dialog'>
				<!-- Modal content-->
				<div class='modal-content'>
					<div class='modal-header'>
						<h4 id='topologyTitle' class='modal-title'>Blockchain Simulator</h4>
						<button type='button' class='close' data-dismiss='modal'>&times;</button>
					</div>
					<div class='modal-body' style='font-size:small'>
						<p>
							Blockchain and the proof-of-work (PoW) distributed consensus protocol rely on peer-to-peer (P2P) networking. We introduce a PoW P2P simulator for the modeling and analyses of permissionless blockchain and cryptocurrency. We publish our simulator in open source to facilitate its use for blockchain and P2P networking research and especially recommend it for scalability research or preliminary testing.
							<hr>
							Visit the GitHub repository <a href='https://github.com/simewu/blockchain-simulator'>here</a>. Additionally, if you have any questions, comments, or suggestions, please send them to <span id='contactAddress'></span>.
							<hr>
							We appreciate you using our app. If you'd like to support us, donations can be made to the following Bitcoin address <a href='https://www.blockchain.com/btc/address/188R8dBjRcCyR7MPwtY6tWiFyapdBapGFh' target='_blank'>188R8dBjRcCyR7MPwtY6tWiFyapdBapGFh</a>.
						</p>
						<p style='text-align:center'>
							<a href='https://www.blockchain.com/btc/address/188R8dBjRcCyR7MPwtY6tWiFyapdBapGFh' target='_blank'>
								<svg shape-rendering='crispEdges' height='128' width='128' style='display:block;margin:5px auto' viewBox='0 0 29 29' class='qrcode'><path fill='#FFF' d='M0,0 h29v29H0z'></path><path fill='#000' d='M0 0h7v1H0zM8 0h1v1H8zM10 0h1v1H10zM12 0h1v1H12zM15 0h4v1H15zM20 0h1v1H20zM22,0 h7v1H22zM0 1h1v1H0zM6 1h1v1H6zM9 1h6v1H9zM17 1h2v1H17zM22 1h1v1H22zM28,1 h1v1H28zM0 2h1v1H0zM2 2h3v1H2zM6 2h1v1H6zM8 2h3v1H8zM13 2h1v1H13zM18 2h1v1H18zM20 2h1v1H20zM22 2h1v1H22zM24 2h3v1H24zM28,2 h1v1H28zM0 3h1v1H0zM2 3h3v1H2zM6 3h1v1H6zM8 3h3v1H8zM12 3h4v1H12zM20 3h1v1H20zM22 3h1v1H22zM24 3h3v1H24zM28,3 h1v1H28zM0 4h1v1H0zM2 4h3v1H2zM6 4h1v1H6zM8 4h1v1H8zM11 4h2v1H11zM14 4h7v1H14zM22 4h1v1H22zM24 4h3v1H24zM28,4 h1v1H28zM0 5h1v1H0zM6 5h1v1H6zM10 5h2v1H10zM13 5h1v1H13zM16 5h1v1H16zM19 5h1v1H19zM22 5h1v1H22zM28,5 h1v1H28zM0 6h7v1H0zM8 6h1v1H8zM10 6h1v1H10zM12 6h1v1H12zM14 6h1v1H14zM16 6h1v1H16zM18 6h1v1H18zM20 6h1v1H20zM22,6 h7v1H22zM10 7h1v1H10zM12 7h1v1H12zM17 7h1v1H17zM19 7h2v1H19zM0 8h4v1H0zM6 8h1v1H6zM8 8h1v1H8zM10 8h3v1H10zM14 8h1v1H14zM17 8h5v1H17zM24 8h3v1H24zM28,8 h1v1H28zM0 9h1v1H0zM5 9h1v1H5zM8 9h1v1H8zM10 9h1v1H10zM12 9h1v1H12zM14 9h1v1H14zM16 9h1v1H16zM20 9h1v1H20zM22 9h1v1H22zM24 9h1v1H24zM27,9 h2v1H27zM0 10h1v1H0zM2 10h2v1H2zM6 10h1v1H6zM9 10h4v1H9zM14 10h1v1H14zM16 10h1v1H16zM18 10h1v1H18zM22 10h4v1H22zM27 10h1v1H27zM0 11h1v1H0zM3 11h2v1H3zM9 11h2v1H9zM13 11h1v1H13zM16 11h1v1H16zM18 11h2v1H18zM22 11h1v1H22zM28,11 h1v1H28zM0 12h2v1H0zM6 12h2v1H6zM9 12h2v1H9zM12 12h1v1H12zM14 12h2v1H14zM17 12h1v1H17zM19 12h2v1H19zM23 12h2v1H23zM26 12h1v1H26zM1 13h1v1H1zM4 13h2v1H4zM7 13h1v1H7zM11 13h2v1H11zM14 13h6v1H14zM22 13h1v1H22zM25 13h1v1H25zM27,13 h2v1H27zM1 14h2v1H1zM5 14h2v1H5zM9 14h1v1H9zM11 14h1v1H11zM14 14h1v1H14zM18 14h5v1H18zM26,14 h3v1H26zM2 15h4v1H2zM7 15h2v1H7zM10 15h2v1H10zM14 15h2v1H14zM18 15h2v1H18zM21 15h1v1H21zM25 15h1v1H25zM0 16h4v1H0zM6 16h4v1H6zM12 16h1v1H12zM15 16h4v1H15zM20 16h2v1H20zM24 16h1v1H24zM28,16 h1v1H28zM2 17h1v1H2zM4 17h1v1H4zM7 17h1v1H7zM10 17h1v1H10zM13 17h1v1H13zM15 17h1v1H15zM17 17h4v1H17zM22 17h1v1H22zM25 17h2v1H25zM0 18h1v1H0zM2 18h1v1H2zM6 18h4v1H6zM13 18h3v1H13zM18 18h1v1H18zM20 18h2v1H20zM24 18h2v1H24zM2 19h1v1H2zM4 19h1v1H4zM7 19h2v1H7zM10 19h2v1H10zM14 19h7v1H14zM22 19h5v1H22zM28,19 h1v1H28zM1 20h2v1H1zM4 20h3v1H4zM8 20h2v1H8zM14 20h1v1H14zM16 20h2v1H16zM19 20h8v1H19zM28,20 h1v1H28zM8 21h1v1H8zM13 21h1v1H13zM15 21h2v1H15zM20 21h1v1H20zM24,21 h5v1H24zM0 22h7v1H0zM9 22h2v1H9zM14 22h1v1H14zM16 22h1v1H16zM18 22h3v1H18zM22 22h1v1H22zM24 22h1v1H24zM27 22h1v1H27zM0 23h1v1H0zM6 23h1v1H6zM11 23h3v1H11zM16 23h1v1H16zM20 23h1v1H20zM24 23h2v1H24zM0 24h1v1H0zM2 24h3v1H2zM6 24h1v1H6zM9 24h3v1H9zM17 24h1v1H17zM20,24 h9v1H20zM0 25h1v1H0zM2 25h3v1H2zM6 25h1v1H6zM8 25h1v1H8zM11 25h1v1H11zM13 25h6v1H13zM21 25h1v1H21zM24 25h1v1H24zM28,25 h1v1H28zM0 26h1v1H0zM2 26h3v1H2zM6 26h1v1H6zM8 26h3v1H8zM12 26h1v1H12zM14 26h1v1H14zM18 26h2v1H18zM25 26h2v1H25zM28,26 h1v1H28zM0 27h1v1H0zM6 27h1v1H6zM8 27h1v1H8zM10 27h1v1H10zM12 27h2v1H12zM16 27h1v1H16zM18 27h2v1H18zM21 27h4v1H21zM27 27h1v1H27zM0 28h7v1H0zM8 28h1v1H8zM11 28h1v1H11zM16 28h5v1H16zM22 28h2v1H22zM25 28h1v1H25zM27 28h1v1H27z'></path></svg>
							</a>
						</p>
					</div>
				</div>
			</div>
		</div>
	</div>

	<!-- jQuery first, imageMapResizer, then Popper.js, then Bootstrap JS -->
	<script src='lib/jquery-3.2.1.slim.min.js'></script>
	<script src='lib/imageMapResizer.min.js'></script>
	<script src='lib/popper.min.js'></script>
	<script src='lib/bootstrap.min.js'></script>
</body>
<script type='text/javascript'>

	let network = null;

	let updateToolOptions = {
		bitcoinLatencyData: { url: null, data: null },
		canvasVisualizerBarWidth: 15,
		canvasVisualizerInterval: 1000 / 30,
		canvasVisualizerPixelStepSize: 1,
		canvasVisualizerThread: null,
		codeEditorAfterSampling: null,
		codeEditorBeforeSampling: null,
		codeEditorBetweenSamples: null,
		minerStatsTable_active: true,
		nodeLatencyBackup: {},
		requestVisRedrawTimeout: null,
		sampleEndTime: 0,
		sampler_DOM_active: true,
		sampler_running: false,
		samplerData: [],
		samplerLog: [],
		sampleStartTime: 0,
		saveSamplerSettingsTimeout: null,
		selectMinerTimeout: null,
		stopBlocksInFlightWhenStoppingMining: false,
		timeout: null,
		updateMinerListTimeout: null,
		visBorderSize: 'default', // Changes according to zoom: ['none', 'small', 'default', 'large']
		visLineLength: undefined,
		visNetwork: null,
		visNodeIDs: [],
		visSimulationActive: true,
		visTimeout: null,
	}

	// Use the 256-bit secure hashing algorithm (SHA256) by calling sha256('data string')
	const sha256 = function a(b) {function c(a,b) {return a>>>b|a<<32-b}for(var d,e,f=Math.pow,g=f(2,32),h="length",i="",j=[],k=8*b[h],l=a.h=a.h||[],m=a.k=a.k||[],n=m[h],o= {},p=2;64>n;p++)if(!o[p]) {for(d=0;313>d;d+=p)o[d]=p;l[n]=f(p,.5)*g|0,m[n++]=f(p,1/3)*g|0}for(b+="\x80";b[h]%64-56;)b+="\x00";for(d=0;d<b[h];d++) {if(e=b.charCodeAt(d),e>>8)return;j[d>>2]|=e<<(3-d)%4*8}for(j[j[h]]=k/g|0,j[j[h]]=k,e=0;e<j[h];) {var q=j.slice(e,e+=16),r=l;for(l=l.slice(0,8),d=0;64>d;d++) {var s=q[d-15],t=q[d-2],u=l[0],v=l[4],w=l[7]+(c(v,6)^c(v,11)^c(v,25))+(v&l[5]^~v&l[6])+m[d]+(q[d]=16>d?q[d]:q[d-16]+(c(s,7)^c(s,18)^s>>>3)+q[d-7]+(c(t,17)^c(t,19)^t>>>10)|0),x=(c(u,2)^c(u,13)^c(u,22))+(u&l[1]^u&l[2]^l[1]&l[2]);l=[w+x|0].concat(l),l[4]=l[4]+w|0}for(d=0;8>d;d++)l[d]=l[d]+r[d]|0}for(d=0;8>d;d++)for(e=3;e+1;e--) {var y=l[d]>>8*e&255;i+=(16>y?0:"")+y.toString(16)}return i};

	// Network class
	class Network {
		constructor() {
			this.name = '';

			this.peers = {};
			this.difficulty = 0.01;

			this.blockSize = 1000000;

			this.genesis = new Header();
			this.genesis.height = 0;
			this.genesis.timestamp = Date.now();

			this.useSHA256 = false; // Specify whether or not to actually use genuine hashing (real security, but slow), or to use random numbers and a difficulty threshold to determine a block (no security, but fast)

			this.ID_Registry = {};
			this.miningThreads = {};
			this.minimumBlockchainPurgeLength = 100;
			this.maximumBlockchainPurgeLength = 200; // When a miner's blockchain reaches this many blocks, it will remove the oldest ones until it's the minimumBlockchainPurgeLength

			// When a block is received, keep track of number of networking data, such as the number of hops
			this.logging = {
				columns: {
					'Sample': true,
					'Sample time': true,
					'Sample tag': false,
					'Miner name': true,
					'Balance': true,
					'Balance %': false,
					'Power (hash/s)': true,
					'Power %': false,
					'Blockchain IDs': true,
					'Blockchain num hops': true,
					'Blockchain travel time (ms)': true,
					'Artificial travel time (ms)': false,
					'Network buffer size limit': true,
					'Blocks in flight': true,
					'Latency (ms)': true,
					'Downlink (MBps)': true,
					'Uplink (MBps)': true,
					'Block height': true,
					'Total blocks found': true,
					'Stale blocks found': true,
					'Max fork length': true,
				},
				logNetworkData: false,
				msPerSample: 20000,
				codeBeforeSampling: 'console.log(\'Sampling started at \', Date.now());',
				codeBetweenSamples: '',
				codeAfterSampling: 'console.log(\'Sampling ended at \', Date.now());',
				logSamples: false,
				resetBlockchainAfterEachSample: true,
				updateTableAfterEachSample: true,
				canvasVisualizerCode: 'miner.lastAcceptedBlock',
			}
		}

		setDifficulty(_difficulty) {
			_difficulty = _difficulty.toString();

			if(_difficulty.startsWith('0x')) {
				_difficulty = _difficulty.substring(2); // Remove the 0x
				let maxDifficulty = parseInt('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'.substring(0, 15), 16);
				let d = parseInt(_difficulty.substring(0, 15), 16) / maxDifficulty;
				if(!isNaN(d)) {
					this.difficulty = d;
				} else {
					alert(`Invalid difficulty value: '${_difficulty}'.`);
				}
			} else {
				let d = parseFloat(_difficulty);
				if(!isNaN(d)) {
					this.difficulty = d;
				} else {
					alert(`Invalid difficulty value: '${_difficulty}'.`);
				}
			}
		}

		startAllMiners() {
			for(let id in network.ID_Registry) {
				this.peers[id].startMining();
			}
		}

		stopAllMiners() {
			for(let id in network.ID_Registry) {
				this.peers[id].stopMining();
			}
			if(updateToolOptions.stopBlocksInFlightWhenStoppingMining) {
				this.removeBlocksInFlight();
				for(let id in network.ID_Registry) {
					this.peers[id].setVisualizerColor(); // Fix all the colors
				}
			}
		}

		removeBlocksInFlight() {
			for(let id in network.ID_Registry) {
				this.peers[id].networkBuffer.clear();
			}
		}

		clearBlockchain() {
			for(let id in this.ID_Registry) {
				this.peers[id].clearBlockchain();
				this.peers[id].networkBuffer.clear();
			}
			clearAllTimeouts();
		}
		findPeerByName(name) {
			for(let id in this.ID_Registry) {
				if(this.peers[id].name == name) return this.peers[id];
			}
			return null;
		}

		// Given a network object, return it in its serialized JSON form
		static serialize(network, compress = true) {
			network.stopAllMiners();
			network.removeBlocksInFlight();
			let newNetwork = null, destructive = false;
			try {
				let json = JSON_stringify(network);
				// Now clone it, remove the temporary properties such as blockchain, then re-convert to JSON
				newNetwork = JSON_parse(json);
			} catch(e) {
				let proceed = confirm('There was an out-of-memory error cloning the network for serialization.\n\nWould you like to proceed with successful serialization at the cost of potentially corrupting the current network instance?');
				if(!proceed) return;
				destructive = true;
				newNetwork = network; // Don't clone it
			}
			delete newNetwork.genesis;
			for(let ID in newNetwork.peers) {
				let peer = newNetwork.peers[ID];
				delete peer.lastAcceptedBlock;
				delete peer.blockchain;
				delete peer.blockchainOffset;
				delete peer.currentHeader;
				delete peer.totalBlocksFound;
				delete peer.staleBlocksFound;
				delete peer.largestForkLength;
				delete peer.blockchain_blockID;
				delete peer.blockchain_numHops;
				delete peer.blockchain_blockDelay;
				delete peer.blockchain_artificialBlockDelay;
				delete peer.networkBuffer;
			}
			let restoreNetwork = (json) => {
				// If we removed the network's critical data, rebuild it here
				let fixedNetwork = Network.deserialize(json);
				if(fixedNetwork != null) network = fixedNetwork;
				else console.error('Unable to restore the network, please refresh the page.');
			}
			if(compress) {
				let fixedJSON = JSON_stringify(newNetwork);
				if(destructive) setTimeout(restoreNetwork, 1000, fixedJSON);
				let compressed = LZString.compressToUTF16('\n' + fixedJSON);
				return compressed;
			} else {
				let fixedJSONFormatted = JSON_stringify(newNetwork, null, '\t');
				if(destructive) setTimeout(restoreNetwork, 1000, fixedJSONFormatted);
				return fixedJSONFormatted;
			}
		}

		// Given a serialized network, return the network object (consisting of Network, Miner, Header classes)
		static deserialize(data) {
			clearAllTimeouts();
			let decompressed = LZString.decompressFromUTF16(data);
			if(decompressed != null && decompressed.startsWith('\n')) data = decompressed.substring(1);

			try {
				let newNetworkObj = JSON_parse(data);
				let network = new Network();
				// Add logging if it doesn't exist
				if(newNetworkObj.logging === undefined) newNetworkObj.logging = network.logging;
				if(newNetworkObj.logging.columns === undefined) newNetworkObj.logging.columns = network.logging.columns;

				// Merge the columns together
				for(let column in network.logging.columns) {
					if(newNetworkObj.logging.columns[column] !== undefined) {
						network.logging.columns[column] = newNetworkObj.logging.columns[column];
					}
				}
				newNetworkObj.logging.columns = network.logging.columns;

				network = Object.assign(network, newNetworkObj);

				

				for(let peer in network.peers) { // Make all miners Miner objects

					let miner = new Miner(network.peers[peer].name, network.peers[peer].power, network.peers[peer].latency, network.peers[peer].bandwidth?.downlink || network.peers[peer].downloadMBPS, network.peers[peer].bandwidth?.uplink || network.peers[peer].uploadMBPS);
					miner = Object.assign(miner, network.peers[peer]);
					network.peers[peer] = miner;

					// Make the currentHeader an actual Header object
					let currentHeader = new Header();
					currentHeader = Object.assign(currentHeader, network.peers[peer].currentHeader);
					network.peers[peer].currentHeader = currentHeader;

					let lastAcceptedBlock = currentHeader.clone();
					// And so that it doesn't affect the color:
					delete lastAcceptedBlock.numHops;
					delete lastAcceptedBlock.propagationTime;

					// Backward compatibility to support outgoingPeers arrays; convert them to latency objects
					miner.latency = miner.latency || 0;
					if(Array.isArray(miner.outgoingPeers)) {
						let updatedOutgoingPeers = {};
						for(let id of miner.outgoingPeers) {
							updatedOutgoingPeers[id] = miner.latency;
						}
						miner.outgoingPeers = updatedOutgoingPeers;
					}

					// Copy over the bandwidth
					let bandwidth = {uplink: Infinity, downlink: Infinity};
					bandwidth = Object.assign(bandwidth, network.peers[peer].bandwidth);
					network.peers[peer].bandwidth = bandwidth;
					if(network.peers[peer].downloadMBPS !== undefined && network.peers[peer].uploadMBPS !== undefined) {
						delete network.peers[peer].downloadMBPS;
						delete network.peers[peer].uploadMBPS; // Backward compatibility
					}

					delete network.peers[peer].networkBufferManager; // Clean up old version data

					// Make the blocks in the blockchain an actual Header object
					for(let block in network.peers[peer].blockchain) {
						let header = new Header();
						header = Object.assign(header, network.peers[peer].blockchain[block]);
						network.peers[peer].blockchain[block] = header;
					}

					// Recreate the networkBuffer
					let networkBuffer = new NetworkBuffer(miner.ID);
					network.peers[peer].networkBuffer = networkBuffer;
				}
				return network;
			} catch(e) {
				console.error(e);
				alert('Error deserializing the network. See console for more information.');
				return null;
			}
		}
	}

	// Block header class
	class Header {
		constructor() {
			this.solver = null;
			this.height = null;
			this.timestamp = null; // Time block was solved in seconds

			if(network != null) this.numBytes = network.blockSize;
			else this.numBytes = 1000000;

			this.nonce = null;
			this.hash = null;
			this.prevHash = null;
			this.balances = {};
			if(network && network.logging.logNetworkData) {
				this.numHops = 0;
				this.propagationTime = 0;
			}
		}

		clone() {
			let newHeader = new Header();
			newHeader.solver = this.solver;
			newHeader.height = this.height;
			newHeader.timestamp = this.timestamp;
			newHeader.hash = this.hash;
			newHeader.prevHash = this.prevHash;
			newHeader.balances = Object.assign({}, this.balances);
			if(network.logging.logNetworkData) {
				newHeader.numHops = this.numHops;
				newHeader.propagationTime = this.propagationTime;
			}
			return newHeader;
		}

		static fromObj(obj) {
			let block = new Header();
			if(obj.solver !== undefined) block.solver = obj.solver;
			if(obj.height !== undefined) block.height = obj.height;
			if(obj.timestamp !== undefined) block.timestamp = obj.timestamp;
			if(obj.numBytes !== undefined) block.numBytes = obj.numBytes;
			if(obj.nonce !== undefined) block.nonce = obj.nonce;
			if(obj.hash !== undefined) block.hash = obj.hash;
			if(obj.prevHash !== undefined) block.prevHash = obj.prevHash;
			if(obj.balances !== undefined) block.balances = obj.balances;
			if(obj.numHops !== undefined) block.numHops = obj.numHops;
			if(obj.propagationTime !== undefined) block.propagationTime = obj.propagationTime;
			return block;
		}

		guessNonce() {
			this.nonce = Math.random();
			if(network.useSHA256) {
				// Secure but slower
				const data = this.timestamp.toString() + this.nonce.toString() + this.solver?.toString() + this.height.toString() + this.prevHash?.toString() + this.balances.toString();
				this.hash = sha256(sha256(data));
			} else {
				// Insecure but fast
				this.hash = this.nonce;
			}
		}

		isBlock() {
			if(network.useSHA256) {
				// Secure but slower
				const targetDifficulty = 1152921504606847000; // 0xFFFFFFFFFFFFFFF
				const currentDifficulty = parseInt(this.hash.substring(0, 15), 16);
				return (currentDifficulty / targetDifficulty) <= network.difficulty;
			} else {
				// Insecure but fast
				return this.hash <= network.difficulty;
			}
		}
	}

	class NetworkBuffer {
		constructor(parentID) {
			this.parentID = parentID;
			this.bufferSizeLimit = Infinity;
			this.clear();
		}

		// Stop and clear the network buffer
		clear() {
			this.buffer = [];
			clearTimeout(this.thread);
			this.thread = null;
			this.nextInterval = null;
		}

		// If the thread is null, then schedule the next processBuffer function call
		activateBufferProcessor() {
			if(this.thread == null) {
				let packet = this.buffer[0], delay;
				if(packet.to == this.parentID) { // Downloading data
					delay = packet.size / 1000000 / network.peers[this.parentID].bandwidth.downlink * 1000;
				} else { // Uploading data6
					delay = packet.size / 1000000 / network.peers[this.parentID].bandwidth.uplink * 1000;
				}

				if(network.logging.logNetworkData) {
					packet.payload.propagationTime += delay;
				}

				if(delay == 0) {
					this.thread = setTimeout(() => {}, delay);
					this.processBuffer();
				} else {
					this.thread = setTimeout(this.processBuffer.bind(this), delay);
				}
				
				this.nextInterval = delay;
			}
		}

		// Process the next item in the network buffer queue
		processBuffer() {
			if(this.buffer.length == 0) {
				clearTimeout(this.thread);
				this.thread = null;
				return;
			}

			// Process the packet
			let packet = this.buffer.shift();

			if(packet.to == this.parentID) { // Downloading data
				let parent = network.peers[this.parentID];
				let latency = 0; // Optionally also have a latency for download latency (alongside upload latency), disabled by default

				// Log the artificial block delay/propagation time
				if(network.logging.logNetworkData) {
					packet.payload.propagationTime += latency;
				}

				// After latency (default=0) milliseconds, call the miner's receive(packet.from, packet.payload) function
				setTimeout(parent.receive.bind(parent), latency, packet.from, packet.payload);

			} else { // Uploading data
				let latency = network.peers[this.parentID].outgoingPeers[packet.to] ?? network.peers[this.parentID].latency;
				let networkBufferTo = network.peers[packet.to].networkBuffer;

				if(networkBufferTo.bufferSizeLimit === Infinity || networkBufferTo.buffer.length < networkBufferTo.bufferSizeLimit) {

					// Log the artificial block delay/propagation time
					if(network.logging.logNetworkData) {
						packet.payload.propagationTime += latency;
					}

					setTimeout(function(networkBufferTo, packet) {
						networkBufferTo.buffer.push(packet);
						networkBufferTo.activateBufferProcessor();
					}, latency, networkBufferTo, packet);
					
				} // Else their size is too full and the packet must be dropped
			}

			// Schedule the next buffer process
			let delay = 0;
			if(this.buffer.length > 0) {
				let packet = this.buffer[0];
				if(packet.to == this.parentID) { // Downloading data
					delay = packet.size / 1000000 / network.peers[this.parentID].bandwidth.downlink * 1000;
				} else { // Uploading data
					delay = packet.size / 1000000 / network.peers[this.parentID].bandwidth.uplink * 1000;
				}
			}

			// Log the artificial block delay/propagation time
			if(network.logging.logNetworkData) {
				packet.payload.propagationTime += delay;
			}

			if(delay == 0) {
				this.thread = setTimeout(() => {}, 0);
				this.processBuffer();
			} else {
				this.thread = setTimeout(this.processBuffer.bind(this), delay);
			}
			this.nextInterval = delay;
		}

		send(to_ID, data) {
			let packet = {
				from: this.parentID,
				to: to_ID,
				payload: data,
				size: data.numBytes
			}
			if(network.logging.logNetworkData) {
				if(packet.payload.propagationTime === undefined) packet.payload.propagationTime = 0;
			}
			this.buffer.push(packet);
			this.activateBufferProcessor();
		}
	}

	// Miner class
	class Miner {
		constructor(name, power, latency, downlinkMBPS, uplinkMBPS) {
			this.name = name;
			// Register a unique ID
			if(network.ID_Registry[this.name] === undefined) {
				this.ID = this.name.toUpperCase().replace(/\s/g, '_'); // Math.random().toString();
			} else { // Guarentee that no peers have the same ID
				let count = 1;
				do {
					this.ID = this.name.toUpperCase().replace(/\s/g, '_') + count;
					count++;
				} while(network.ID_Registry[this.ID] !== undefined);
			}
			network.ID_Registry[this.ID] = null;
			network.peers[this.ID] = this;
			this.power = power;
			this.latency = latency; // Additional latency from the network (milliseconds)
			this.outgoingPeers = {};
			this.incomingPeers = [];
			this.bandwidth = {
				downlink: downlinkMBPS, // Used by the download buffer to receive data
				uplink: uplinkMBPS // Used by the upload buffer to send data
			}

			this.sendInvalidMaliciousBlocks = false; // When enabled, this miner will mine like other miners, however when a 'block' is found, it is actually an invalid block, so adjacent nodes will decline it, but it will have already used up part of the neighboring node's bandwidths

			this.lastAcceptedBlock = null;
			this.blockchainOffset = 0; // Due to removing old blocks
			this.blockchain = [network.genesis];
			this.totalBlocksFound = 0;
			this.staleBlocksFound = 0;
			this.largestForkLength = 0;
			this.currentHeader = this.newHeader(network.genesis);
			this.addCoinbaseTransaction();
			this.color = 'default';
			this.networkBuffer = new NetworkBuffer(this.ID);

			if(network.logging.logNetworkData) {
				this.blockchain_blockID = [];
				this.blockchain_numHops = [];
				this.blockchain_blockDelay = [];
				this.blockchain_artificialBlockDelay = [];
			}
			updateTools();
		}

		destructor() {
			this.stopMining();
			let incomingPeersBackup = this.incomingPeers.slice();
			let outgoingPeersBackup = Object.assign({}, this.outgoingPeers);

			for(let id in outgoingPeersBackup) {
				this.removeConnection(id);
			}
			for(let id of incomingPeersBackup) {
				if(network.peers[id] !== undefined) {
					network.peers[id].removeConnection(this.ID);
				}
			}
			delete network.ID_Registry[this.ID];
			updateTools();
		}

		getBlock(height) {
			let block = this.blockchain[height - this.blockchainOffset];
			
			if(block === undefined) return null;

			if(block instanceof Header) {
				return block;
			} else {
				let fixedBlock = Header.fromObj(block);
				this.blockchain[height - this.blockchainOffset] = fixedBlock;
				return fixedBlock;
			}
		}

		setBlock(height, block) {
			if(block == undefined) return;
			if(network.logging.logNetworkData && this.blockchain_blockID !== undefined && this.blockchain_numHops !== undefined && this.blockchain_blockDelay !== undefined && this.blockchain_artificialBlockDelay !== undefined) { // Keep track of networking data
				// If there is a fork, it will always stay up to date by replacing the old stale block data
				this.blockchain_blockID[height] = block.hash;
				this.blockchain_numHops[height] = block.numHops;
				this.blockchain_artificialBlockDelay[height] = block.propagationTime;
				this.blockchain_blockDelay[height] = Date.now() - block.timestamp;
				if(this.blockchain_artificialBlockDelay[height] === undefined)
					this.blockchain_artificialBlockDelay[height] = 0;
			}
			this.blockchain[height - this.blockchainOffset] = block;
			this.lastAcceptedBlock = block.clone();
			// And so that it doesn't affect the color:
			delete this.lastAcceptedBlock.numHops;
			delete this.lastAcceptedBlock.propagationTime;
		}

		// Clear all blockchain data
		clearBlockchain() {
			this.blockchainOffset = 0;
			this.blockchain = [network.genesis];
			this.currentHeader = this.newHeader(network.genesis);
			this.addCoinbaseTransaction();
			this.lastAcceptedBlock = this.currentHeader.clone();
			this.totalBlocksFound = 0;
			this.staleBlocksFound = 0;
			this.largestForkLength = 0;
			if(network.logging.logNetworkData) {
				this.blockchain_blockID = [];
				this.blockchain_numHops = [];
				this.blockchain_blockDelay = [];
				this.blockchain_artificialBlockDelay = [];
			}
		}

		// Memory optimization with no impact on network, nodes become pruned nodes
		// Check if it is time to remove old blocks, if it is, remove them
		purgeBlockCheck() {
			if(this.blockchain.length >= network.maximumBlockchainPurgeLength) {
				this.blockchainOffset += this.blockchain.length - network.minimumBlockchainPurgeLength;
				this.blockchain = this.blockchain.slice(this.blockchain.length - network.minimumBlockchainPurgeLength);
			}
		}

		startMining() {
			if(network.miningThreads[this.ID] !== undefined) return;
			if(this.power == 0) return;
			network.miningThreads[this.ID] = setInterval(this.mine.bind(this), 1000 / this.power);
			$('#minerList option[value="' + this.ID + '"]').html('&#10148; ' + this.name);
		}

		stopMining() {
			clearInterval(network.miningThreads[this.ID]);
			delete network.miningThreads[this.ID];
			$('#minerList option[value="' + this.ID + '"]').html(this.name);
		}

		mine() {
			this.currentHeader.timestamp = Date.now();
			if(this.sendInvalidMaliciousBlocks) {
				while(!this.currentHeader.isBlock()) { // No blocks
					this.currentHeader.guessNonce();
				};
				this.submit(this.currentHeader);
				return;
			}
			this.currentHeader.guessNonce();

			// If it's a malicious node, void the block by guessing another nonce until it is not a block

			if(this.currentHeader.isBlock()) {
				//console.log(this.name + ' found a block!');
				this.submit(this.currentHeader);
				this.totalBlocksFound++;
				// Set it as the new currentHeader, to mine off of
				this.setBlock(this.currentHeader.height, this.currentHeader);
				this.currentHeader = this.newHeader(this.currentHeader);
				this.addCoinbaseTransaction();
				this.purgeBlockCheck();
			}
		}

		addConnection(ID) {
			if(this.ID == ID) return;
			this.outgoingPeers[ID] = this.latency;
			network.peers[ID].incomingPeers.push(this.ID);
			updateTools();
		}

		removeConnection(ID) {
			delete this.outgoingPeers[ID];

			// Remove us from that peer's incoming peer list
			if(network.peers[ID] !== undefined) {
				//delete network.peers[ID].incomingPeers[this.ID];
				for(let i in network.peers[ID].incomingPeers) {
					if(network.peers[ID].incomingPeers[i] == this.ID) {
						network.peers[ID].incomingPeers.splice(i, 1);
					}
				}
			}
			updateTools();
		}

		newHeader(prevHeader) {
			const header = new Header();
			header.solver = this.ID;
			header.hash = Number.MAX_SAFE_INTEGER;

			if(prevHeader !== undefined) {
				header.height = prevHeader.height + 1;
				header.prevHash = prevHeader.hash;
				header.balances = Object.assign({}, prevHeader.balances);
			}
			return header;
		}

		addCoinbaseTransaction() {
			if(this.currentHeader.balances[this.ID] === undefined) {
				this.currentHeader.balances[this.ID] = 1;
			} else {
				this.currentHeader.balances[this.ID]++;
			}
		}

		// Set the node's color in the network visualizer
		setVisualizerColor(color) {
			if(!updateToolOptions.visSimulationActive) return;
			let visID = updateToolOptions.visNodeIDs[this.ID];
			let visRawNodeData = updateToolOptions.visNetwork.nodesHandler.body.nodes[visID];
			if(visRawNodeData === undefined) return;
			if(color === undefined) color = this.color;
			if(visRawNodeData.options.color.background == color) return;

			visRawNodeData.options.color.background = color;
			requestVisRedraw();
		}

		receivedBlockUpdateColor() {
			this.setVisualizerColor('#000');
			setTimeout(this.setVisualizerColor.bind(this), 200 + this.latency * 2); // Show the node dot as black for a small amount of time to represent the node receiving a block
			requestVisRedraw();
		}

		// Broadcast a header to all peers
		submit(header) {
			if(network.logging.logNetworkData) {
				// Keep track of number of hops
				if(header.numHops === undefined) header.numHops = 0;
				else header.numHops++;
			}
			if(updateToolOptions.visSimulationActive) this.receivedBlockUpdateColor();
			for(let id in this.outgoingPeers) {
				this.networkBuffer.send(id, header.clone());
			}
		}

		// Called when a header is received
		receive(from_ID, newHeader) {
			//console.log('Block ' + newHeader.height + ': Received by ' + this.ID);
			if(!newHeader.isBlock()) return; // Invalid block message

			if(newHeader.height >= this.blockchain.length + this.blockchainOffset) {
				// If at any point in receiving a block, there is an undefined header, this allows us to undo to the previous working header
				let backupHeaders = [];
				backupHeaders.push(this.getBlock(newHeader.height));
				this.setBlock(newHeader.height, newHeader);
				this.currentHeader = this.newHeader(newHeader);
				this.addCoinbaseTransaction();
				let solver = network.peers[newHeader.solver];
				//let newHeader = newHeader; // Go back through the blockchain until we reach the block that both miners share
				let forkLength = 1;
				while(this.getBlock(newHeader.height - 1) == null || newHeader.prevHash != this.getBlock(newHeader.height - 1).hash) {
					 // Stale block detector
					if(this.getBlock(newHeader.height - 1) != null && this.ID == this.getBlock(newHeader.height - 1).solver) {
						this.staleBlocksFound++;
						//console.log(this.getBlock(newHeader.height - 1).solver + ''s block became stale');
					}
					let i = newHeader.height;
					newHeader = solver.queryBlockAtHeight(newHeader.height - 1);
					if(newHeader === undefined) {
						while(backupHeaders.length > 0) {
							this.setBlock(i, backupHeaders.pop());
							i++;
						}
						//console.log('Recovered from incomplete transfer');
						return;
					}
					backupHeaders.push(this.getBlock(newHeader.height));
					this.setBlock(newHeader.height, newHeader);
					forkLength++;
				} // Fully synced blockchain!
				if(forkLength > this.largestForkLength) {
					this.largestForkLength = forkLength;
				}
				this.purgeBlockCheck();
				if(updateToolOptions.visSimulationActive) this.receivedBlockUpdateColor();

				this.submit(this.getBlock(this.blockchain.length + this.blockchainOffset - 1));
			}
		}

		queryBlockAtHeight(height) {
			if(this.getBlock(height) == null) return;
			return this.getBlock(height).clone();
		}
	}

	network = new Network();

	// Quickly mine the genesis block
	do {
		network.genesis.guessNonce();
	} while(!network.genesis.isBlock());

	const noSleep = new NoSleep();

	setupSampleCodeEditors();

	const jsoneditorContainer = document.getElementById('jsoneditor');
	const jsoneditor = new JSONEditor(jsoneditorContainer, {
		mode: 'tree',
		modes: ['code', 'form', 'tree'],
		onChangeText: function (jsonString) {
			DOM_editMiner();
		},
	});
	const topologyjsoneditorContainer = document.getElementById('topologyjsoneditor');
	const topologyjsoneditor = new JSONEditor(topologyjsoneditorContainer, {
		mode: 'form',
		modes: ['code', 'form', 'text', 'tree', 'view']
	});
	const networkjsoneditorContainer = document.getElementById('networkjsoneditor');
	const networkjsoneditor = new JSONEditor(networkjsoneditorContainer, {
		mode: 'view',
		modes: ['code', 'form', 'text', 'tree', 'view'],
		onChangeText: function (jsonString) {
			DOM_editNetwork();
		}
	});

	// Scroll to the bottom of the page
	function scrollToBottomOfPage() {
		window.scrollTo(0,document.body.scrollHeight);
	}

	// Check if an element is within view
	function elementInViewport(element) {
		if(element == null || element === undefined) return true;
		var top = element.offsetTop;
		var left = element.offsetLeft;
		var width = element.offsetWidth;
		var height = element.offsetHeight;
		while(element.offsetParent) {
			element = element.offsetParent;
			top += element.offsetTop;
			left += element.offsetLeft;
		}
		return (
			top >= window.pageYOffset &&
			left >= window.pageXOffset &&
			(top + height) <= (window.pageYOffset + window.innerHeight) &&
			(left + width) <= (window.pageXOffset + window.innerWidth)
		);
	}

	// Clear all currently running timeouts
	function clearAllTimeouts() {
		var id = window.setTimeout(function() {}, 0);
		while (id--) {
			window.clearTimeout(id);
		}
	}

	// foobar --> Foobar
	function fixCase(str) {
		return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
	}

	// Generate a random integer between a and b
	function rnd(a, b) {
		if(a == b) return a;
		else if(b > a) [a, b] = [b, a];
		return Math.floor(a + Math.random() * (b - a + 1));
	}

	// Randomize array in-place using Durstenfeld shuffle algorithm
	function shuffleArray(array) {
		for (var i = array.length - 1; i > 0; i--) {
			var j = Math.floor(Math.random() * (i + 1));
			var temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
		return array
	}

	// Added support for Infinity and NaN values
	function JSON_stringify(obj, replacer = null, space = null) {
		return JSON.stringify(obj, function(name, val) {
			if(typeof(val) === 'number' && (isNaN(val) || !isFinite(val))) return val.toString();
			return val;
		}, space);
	}

	// Added support for Infinity and NaN values
	function JSON_parse(obj) {
		return JSON.parse(obj, function(name, val) {
			if(typeof(val) === 'string') {
				if(!isNaN(Number(val))) return Number(val);
				else if(val == 'NaN') return NaN;
			}
			return val;
		});
	}

	// Open and return the contents of a file url
	async function openAndReadFile(url) {
		try {
			const response = await fetch(url);
			if(!response.ok) return null;
			return await response.text();
		} catch(e) {
			console.error('Failed to load url "' + url + '".', e.message);
			return null;
		}
	}

	// Convert a CSV-formatted string into a JavaScript array
	function CSVToArray(strData, strDelimiter = ','){
		strDelimiter = (strDelimiter || ',');
		var objPattern = new RegExp(
			(
				// Delimiters.
				'(\\' + strDelimiter + '|\\r?\\n|\\r|^)' +

				// Quoted fields.
				'(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|' +

				// Standard fields.
				'([^\"\\' + strDelimiter + '\\r\\n]*))'
			),
			'gi'
			);
		var arrData = [[]];
		var arrMatches = null;
		while (arrMatches = objPattern.exec(strData)){
			var strMatchedDelimiter = arrMatches[1];
			if (
				strMatchedDelimiter.length &&
				strMatchedDelimiter !== strDelimiter
				){
				arrData.push([]);
			}
			var strMatchedValue;
			if (arrMatches[2]){
				strMatchedValue = arrMatches[2].replace(
					new RegExp('""', 'g'),
					'"');
			} else {
				strMatchedValue = arrMatches[3];
			}
			matchedValue = Number(strMatchedValue);
			if(!isNaN(matchedValue)) {
				arrData[arrData.length - 1].push(matchedValue);
			} else {
				arrData[arrData.length - 1].push(strMatchedValue);
			}
		}
		return arrData;
	}

	// Extracts all strings/quotes from a block of code, replacing them by temporary characters, and returns the resulting string along with the array of quotes
	// " --> \u04DC, ' --> \u04DD, ` --> \u04DE
	function extractQuotes(code) {
		code = code.replace(/\u04DC|\u04DD|\u04DE/g, ''); // Prevent intervention
		let outputCode = '', extractedQuotes = [];
		let split = code.split('\"');
		for(let i in split) {
			if(i % 2 == 0) {
				outputCode += split[i];
			} else {
				outputCode += '\u04DC'
				extractedQuotes.push(split[i]);
			}
		}
		split = outputCode.split('\'');
		outputCode = ''
		for(let i in split) {
			if(i % 2 == 0) {
				outputCode += split[i];
			} else {
				outputCode += '\u04DD'
				extractedQuotes.push(split[i]);
			}
		}
		split = outputCode.split('\`');
		outputCode = ''
		for(let i in split) {
			if(i % 2 == 0) {
				outputCode += split[i];
			} else {
				outputCode += '\u04DE'
				extractedQuotes.push(split[i]);
			}
		}
		return [outputCode, extractedQuotes];
	}

	// Take the output from the extractQuotes function, and return the full code with the strings/quotes inserted
	function reinsertQuotes(array) {
		while(array[0].includes('\u04DC')) {
			array[0] = array[0].replace('\u04DC', '\"' + array[1].shift() + '\"');
		}
		while(array[0].includes('\u04DD')) {
			array[0] = array[0].replace('\u04DD', '\'' + array[1].shift() + '\'');
		}
		while(array[0].includes('\u04DE')) {
			array[0] = array[0].replace('\u04DE', '\`' + array[1].shift() + '\`');
		}
		return array[0];
	}

	// Create a new miner
	function newMiner(name0, power, latency, downlinkMBPS, uplinkMBPS, createNewIfExists = true) {
		let name = name0;
		if(createNewIfExists) {
			// Create a new name/miner by appending a counter to the end, so that the name is unique
			let count = 2;
			while(network.findPeerByName(name) != null) {
				name = name0 + count.toString();
				count++;
			}
		}

		for(let id in network.ID_Registry) {
			if(network.peers[id].name == name) return;
		}
		const miner = new Miner(name, power, latency, downlinkMBPS, uplinkMBPS);
		updateMinerList();
		selectMiner(miner.ID); // Select it
		return miner;
	}

	// Connect every peer to every other peer
	function fullyConnectPeers() {
		for(let id1 in network.ID_Registry) {
			for(let id2 in network.ID_Registry) {
				network.peers[id1].addConnection(id2);
			}
		}
		DOM_setOptionMsg('FULLY CONNECTED', 'topology', 'badge-info');
		DOM_selectedMiner();
	}

	// Make all peer connections bidirectional
	function bidirectionallyConnectPeers() {
		for(let id1 in network.ID_Registry) {
			for(let id2 in network.peers[id1].outgoingPeers) {
				network.peers[id2].addConnection(id1);
			}
		}
		DOM_setOptionMsg('CONNECTED', 'topology', 'badge-info');
		DOM_selectedMiner();
	}

	// Disonnect every peer to every other peer
	function fullyDisconnectPeers() {
		for(let id1 in network.ID_Registry) {
			for(let id2 in network.ID_Registry) {
				network.peers[id1].removeConnection(id2);
			}
		}
		DOM_setOptionMsg('DISCONNECTED', 'topology', 'badge-info');
		DOM_selectedMiner();
	}

	// Remove everyone's copy of the blockchain
	function DOM_clearBlockchain() {
		network.stopAllMiners();
		network.removeBlocksInFlight();
		network.clearBlockchain();
		DOM_setOptionMsg('SUCCESS', 'network', 'badge-success');
		DOM_selectedMiner();
	}

	// Clear the selected miner's blockchain
	function DOM_clearMinerBlockchain() {
		const e = $('#minerList option:selected');
		const miner = network.peers[e.val()];
		if(miner === undefined) {
			DOM_setOptionMsg('NO MINER SELECTED', 'network', 'badge-warning');
		} else {
			miner.clearBlockchain();
			DOM_setOptionMsg('SUCCESS', 'network', 'badge-success');
		}
	}

	// When stopping all miners, also stop all blocks that are currently in flight
	function DOM_toggleStoppingBlocksInFlight() {
		if(updateToolOptions.stopBlocksInFlightWhenStoppingMining) {
			updateToolOptions.stopBlocksInFlightWhenStoppingMining = false;
			$('#stopBlocksInFlightBtn').html('Stop blocks in flight<br>after stopping all miners')
		} else {
			updateToolOptions.stopBlocksInFlightWhenStoppingMining = true;
			$('#stopBlocksInFlightBtn').html('Continue transmitting blocks in<br>flight after stopping all miners')
		}
	}

	$(document).ready(function() {
		// First try loading the filename '', if it doesn't exist, then generate a random topology
		if(loadLocalStorageQuiet('') == false) {
			generateTopology({
				'Type': 'Mesh',
				'Bidirectional': true,
				'Prevent duplicate connections': true,
				'Number of peers': 30,
				'Minimum number of outgoing connections': 1,
				'Maximum number of outgoing connections': 1,
				'Minimum power (hashes per second)': 1,
				'Maximum power (hashes per second)': 4,
				'Minimum downlink (megabytes per second)': Infinity,
				'Maximum downlink (megabytes per second)': Infinity,
				'Minimum uplink (megabytes per second)': Infinity,
				'Maximum uplink (megabytes per second)': Infinity,
				'Minimum latency (milliseconds)': 100,
				'Maximum latency (milliseconds)': 100,
				'Naming cycle': shuffleArray(
					['Node ']
				),
			}, false);
			network.logging.codeBetweenSamples = '// ' + Object.keys(network.ID_Registry)[0] + '.power += 10;\nif(numSamples >= 100000) toggleSampling(false);';
			loadSamplerSettings();
			saveSamplerSettings();
		}

		setTimeout(function() {
			$('#minerList option:first').prop('selected', true);
			$('#minerList option:first').change();
		}, 500);
		DOM_clearOptionMsg();
		updateToolOptions.minerStatsTable_active = !updateToolOptions.minerStatsTable_active;
		DOM_toggleMinerStatsTable();
		updateToolOptions.visSimulationActive = !updateToolOptions.visSimulationActive;
		toggleVisualizations();

		$(window).bind('keydown', function(event) {
			let ctrl = event.ctrlKey || event.metaKey;
			if(event.ctrlKey || event.metaKey) {
				if(event.key == 's') {
					saveToFile(true);
					event.preventDefault();
				} else if(event.key == 'o') {
					loadFromFile();
					event.preventDefault();
				}
			}
		});
	});

	function setupSampleCodeEditors() {
		const options = {
			autofocus: false,
			autohint: true,
			dragDrop: false,
			lineNumbers: true,
			lineWrapping: true,
			lineWiseCopyCut: true,

			lint: {
				esversion: 11
			},
			gutters: ["CodeMirror-lint-markers"],
			lintOnChange: true,

			mode:  {
				name: 'javascript',
				globalVars: true
			},
			readOnly: false,
			theme: 'material-darker',
			undoDepth: 1000,

			matchBrackets: true,
			highlightSelectionMatches: true,
			autoCloseBrackets: true
		};

		const editor1 = CodeMirror.fromTextArea(document.getElementById('codeBeforeSampling'), options);
		const editor2 = CodeMirror.fromTextArea(document.getElementById('codeBetweenSamples'), options);
		const editor3 = CodeMirror.fromTextArea(document.getElementById('codeAfterSampling'), options);

		editor1.on('change',function(cMirror){
			saveSamplerSettings();
		});
		editor2.on('change',function(cMirror){
			saveSamplerSettings();
		});
		editor3.on('change',function(cMirror){
			saveSamplerSettings();
		});

		updateToolOptions.codeEditorBeforeSampling = editor1;
		updateToolOptions.codeEditorBetweenSamples = editor2;
		updateToolOptions.codeEditorAfterSampling = editor3;
	}

	// Format the code editors
	function formatSamplerCode() {
		const editor1 = updateToolOptions.codeEditorBeforeSampling;
		const editor2 = updateToolOptions.codeEditorBetweenSamples;
		const editor3 = updateToolOptions.codeEditorAfterSampling;

		editor1.autoFormatRange({line:0, ch:0}, {line:editor1.lineCount()});
		editor2.autoFormatRange({line:0, ch:0}, {line:editor2.lineCount()});
		editor3.autoFormatRange({line:0, ch:0}, {line:editor3.lineCount()});
	}

	// Load a compressed or uncompressed serialized network
	function loadNetwork(data) {
		if(typeof data != 'string') return false;
		temp_network = Network.deserialize(data);
		if(temp_network == null) return false;
		network = temp_network;

		numPeers = Object.keys(network.peers).length;
		if(numPeers >= 50 && updateToolOptions.visSimulationActive) {
			let disableNetworkVisualizer  = confirm(`You are loading ${numPeers} nodes. Would you like to disable the network visualizer for an increase in performance?`);
			if(disableNetworkVisualizer) {
				toggleVisualizations();
			}
		}

		updateTools();
		updateMinerList();
		loadSamplerSettings();
		if(Object.keys(network.peers).length > 0) selectMiner(Object.keys(network.peers)[0]);
		DOM_toggleLoggingNetworkData(network.logging.logNetworkData);
		DOM_clearOptionMsg();
		return true;
	}

	function saveLocalStorage() {
		_saveSamplerSettings();
		let files = [];
		for (var key in localStorage) {
			if(key.startsWith('NETWORK_FILE_')) {
				files.push(key.substring(13));
			}
		}
		let fileName = prompt('Saving a file as an empty string will load it every time the page is refreshed.\n\nFiles:\n["' + files.join('", "') + '"]\n\nEnter a file name to create/replace:', network.name);
		if(fileName == null) return;

		network.name = fileName;
		fileName = 'NETWORK_FILE_' + fileName;

		let data = Network.serialize(network);
		if(data == null) {
			alert('Unable to serialize the network.');
			return;
		}
		localStorage.setItem(fileName, data);
	}

	function loadLocalStorage() {
		let files = [];
		for (var key in localStorage) {
			if(key.startsWith('NETWORK_FILE_')) {
				files.push(key.substring(13));
			}
		}
		let prefill = network.name;
		if(prefill == '' && files.length == 1) prefill = files[0];
		let fileName = prompt('Files:\n["' + files.join('", "') + '"]\n\nPlease enter a file name to load:', prefill);
		if(fileName == null) return;
		fileName = 'NETWORK_FILE_' + fileName;

		let data = localStorage.getItem(fileName);
		if(data == null) {
			alert('File could not be found.')
		} else {
			let status = loadNetwork(data);
			if(status) DOM_setOptionMsg('LOADED', 'file', 'badge-success');
			else DOM_setOptionMsg('ERROR LOADING', 'file', 'badge-warning');
		}
	}

	function loadLocalStorageQuiet(fileName) {
		fileName = 'NETWORK_FILE_' + fileName;

		let data = localStorage.getItem(fileName);
		return loadNetwork(data);
	}

	function deleteLocalStorage() {
		let files = [];
		for (var key in localStorage) {
			if(key.startsWith('NETWORK_FILE_')) {
				files.push(key.substring(13));
			}
		}
		let fileName = prompt('Files:\n[' + files.join(', ') + ']\n\nPlease enter a file name to delete:');
		if(fileName == null) return;
		fileName = 'NETWORK_FILE_' + fileName;

		localStorage.removeItem(fileName);
	}

	function clearAllLocalStorage() {
		if(confirm('Are you sure you would like to clear all the saved networks from your browser?')) {
			localStorage.clear();
			alert('LocalStorage has been cleared.')
		}
	}

	function saveToFile(compress = true) {
		_saveSamplerSettings();
		let fileName = 'simulator_network.dat';
		if(network.name != '') {
			fileName = 'simulator_network_' + network.name.toString().replace(/\s/g, '_') + '.dat';
		}
		let data = Network.serialize(network, compress);
		if(data == null) {
			alert('Unable to serialize the network.');
			return;
		}
		var a = document.createElement('a');
		if (compress) {
			// ref: https://stackoverflow.com/q/6226189
			var charCode, byteArray = [];
			byteArray.push(254, 255); // BE BOM
			// byteArray.push(255, 254); // LE BOM
			for (var i = 0; i < data.length; ++i) {
				charCode = data.charCodeAt(i);
				byteArray.push((charCode & 0xFF00) >>> 8); // BE Bytes
				byteArray.push(charCode & 0xFF);
				// byteArray.push(charCode & 0xff); // LE Bytes
				// byteArray.push(charCode / 256 >>> 0);
			}
			var blob = new Blob([new Uint8Array(byteArray)], {
				type: 'text/plain;charset=UTF-16BE;'
			});
			var blobUrl = URL.createObjectURL(blob);
			a.setAttribute('href', blobUrl);
			a.setAttribute('download', fileName);
		} else {
			a.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(data));
			a.setAttribute('download', 'simulator_network_' + network.name.replace(/\s/g, '_') + '.json');
		}
		a.click();
		a.remove();
		DOM_setOptionMsg('SAVED', 'file', 'badge-info');
	}

	function DOM_copyToClipboardButton() {
		$('#copyToClipboardTextarea').select();
		document.execCommand('copy');
	}

	function DOM_saveToClipboard() {
		_saveSamplerSettings();
		let data = Network.serialize(network);
		if(data == null) {
			alert('Unable to serialize the network.');
			return;
		}
		$('#copyToClipboardTextarea').val(data);
		$('#copyToClipboardTextarea').focus(function() {
			$(this).select();
		});
	}

	function DOM_loadFromClipboard() {
		$('#pasteNetworkTextarea').val('');
		navigator.clipboard.readText()
		.then(data => {
			$('#pasteNetworkTextarea').val(data);
			setTimeout(function(){
				$('#loadPastedNetworkBtn').click();
			}, 500);
		})
		.catch(err => {});
	}

	function loadAboutModal() {
		setTimeout(function() {
			$('#contactAddress').html(LZString.decompressFromEncodedURIComponent('DwQwBAFgTgpgZgXgEQFsQEsA2AXA9gLgGcB3AV2wnRigAFSBjewgOhgBNSkA+E8y6uoxbtSwAPQguQA'));
		}, 1000);
	}

	function DOM_loadPastedNetwork() {
		let data = $('#pasteNetworkTextarea').val()

		let status = loadNetwork(data);
		if(status) DOM_setOptionMsg('LOADED', 'file', 'badge-success');
		else DOM_setOptionMsg('ERROR LOADING', 'file', 'badge-warning');
	}

	function loadFromFile() {
		file = new Promise((resolve) => {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = '.json, .dat'
			input.addEventListener('change', () => {
				resolve(input.files[0]);
			});
			input.click();
		}).then(file => {
			//var file = e.dataTransfer.files[0],
			read = new FileReader();
			read.readAsText(file, 'text/plain;charset=UTF-16BE;');
			read.onloadend = function(){
				let data = read.result;
				let status = loadNetwork(data);
				if(status) DOM_setOptionMsg('OPENED', 'file', 'badge-success');
				else DOM_setOptionMsg('ERROR OPENING', 'file', 'badge-warning');
			}
		});
	}

	// Called when a node is created or deleted
	function updateTools() {
		if(updateToolOptions.timeout != null) return;
		updateToolOptions.timeout = setTimeout(_updateTools, 300);
	}

	// Cannot be called more than once every 300ms
	function _updateTools() {
		if(updateToolOptions.minerStatsTable_active) {
			updateMinerStatsTable();
		}
		if(updateToolOptions.visSimulationActive) {
			vis_setupNetworkSimulation();
		}
		updateToolOptions.timeout = null;
	}

	// Update the list of miners
	function updateMinerList() {
		clearTimeout(updateToolOptions.updateMinerListTimeout);
		updateToolOptions.updateMinerListTimeout = setTimeout(_updateMinerList, 300);
	}

	// Update the list of miners
	function _updateMinerList() {
		$('#minerList').empty();
		for(let peer in network.peers) {
			$('#minerList').append('<option value="' + peer + '">' + network.peers[peer].name + '</option>');
		}
		if(updateToolOptions.selectedMiner == null) updateToolOptions.selectedMiner = Object.keys(network.peers)[0];
		selectMiner(updateToolOptions.selectedMiner);
	}

	function addMinerBtnClicked() {
		$('#multiselectAddPeers').empty();
		for(let id in network.ID_Registry) {
			$('#multiselectAddPeers').append('<option value="' + id + '">' + network.peers[id].name + '</option>')
		}
		const selectionID = $('#minerList option:selected').val();
		if(selectionID !== undefined) {
			const miner = network.peers[selectionID];
			$('#addMinerName').val(miner.name);
			$('#addMinerPower').val(miner.power);
			$('#addMinerLatency').val(miner.latency);
			$('#addMinerDownloadMBPS').val(miner.bandwidth.downlink);
			$('#addMinerUploadMBPS').val(miner.bandwidth.uplink);
			for(let id in miner.outgoingPeers) {
				$('#multiselectAddPeers option[value=' + id + ']').prop('selected', true);
			}

		}
	}

	function DOM_selectedMiner() {
		DOM_clearOptionMsg();
		const miner = network.peers[$('#minerList').val()];
		updateMinerJsonEditor(miner);
		if(miner === undefined) return;

		$('#removeMinerBtn').text('Remove ' + miner.name);
		$('#toggleMinerMiningBtn').text('Toggle mining for ' + miner.name);
		$('#clearMinerBlockchainBtn').text('Clear blockchain for  ' + miner.name);

		$('#editMinerBadge').text('');
		if(updateToolOptions.visSimulationActive) try {
			updateToolOptions.visNetwork.selectNodes([updateToolOptions.visNodeIDs[miner.ID]]);
		} catch(e) {}
	}

	// Update the data in the json editor, if id is not provided, just use the selected one from the table
	function updateMinerJsonEditor(id) {
		if(id === undefined) id = network.peers[$('#minerList').val()];

		if(id === undefined) jsoneditor.set({});
		else jsoneditor.update(id);
	}

	// Prevent computational overhead of repeated selectMiner calls
	function selectMiner(id, scrollTo = true) {
		if(id == null) return;
		clearTimeout(updateToolOptions.selectMinerTimeout);
		updateToolOptions.selectMinerTimeout = setTimeout(_selectMiner, 100, id, scrollTo);
	}

	// Select a miner from the mining list
	function _selectMiner(id, scrollTo) {
		updateToolOptions.selectedMiner = id;
		$('#minerList option:selected').prop('selected', false);
		if(id === undefined) return;
		$('#minerList option[value="' + id + '"]').prop('selected', true);
		$('#minerList option:selected').change();
		drawCanvasVisualizerMinerCircles();
		updateToolOptions.selectMinerTimeout = null;

		try {
			if(scrollTo && !network.logging.logNetworkData) {
				setTimeout(function(){
					let element = document.querySelector('#minerList option:checked');
					if(element && !elementInViewport(element)) {
						element.scrollIntoView({
							behavior: 'smooth'
						});
					}
				}, 100);
			}
		} catch(e) {}
	}

	$('#addMinerModal').on('shown.bs.modal', function (e) {
		DOM_clearOptionMsg();
	});

	$('#generateTopologyModal').on('shown.bs.modal', function (e) {
		$('map').imageMapResize();
	});

	function DOM_globalSetPower() {
		DOM_clearOptionMsg();
		const input = prompt('You are about to set the computing power of every miner in the network.\n\n• Enter one expression to set everyone\'s hashes per second the same.\n• Enter two expressions (separated by a space) to set the hashes per second randomly between a range.', '10 100');
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(' '), code1 = input, code2 = '', num1, num2;
		try {
			if(i != -1) {
				code1 = input.substring(0, i);
				code2 = input.substring(i+1, input.length);
			}
			for(let id in network.ID_Registry) {
				if(i == -1) {
					num1 = eval(getDynamicSampleCode(input));
					num2 = num1;
				} else {
					num1 = eval(getDynamicSampleCode(code1));
					num2 = eval(getDynamicSampleCode(code2));
				}
				network.peers[id].power = Math.max(0, rnd(num1, num2))
			}
			updateMinerJsonEditor();
			DOM_setOptionMsg('SUCCESS', 'network', 'badge-success');
		} catch(e) {
			console.log('Setting power code:', code1, code2);
			alert('Error: ' + e + '\n\nSee console for more information');
			console.log('Setting power error:', e);
			DOM_setOptionMsg('UNSUCCESSFUL', 'network', 'badge-error');
		}
	}

	function DOM_globalSetLatency() {
		DOM_clearOptionMsg();
		const input = prompt('You are about to set the network latency (in milliseconds) of every miner in the network.\n\n• Enter one expression to set everyone\'s latency the same.\n• Enter two expressions (separated by a space) to set the latency randomly between a range.', '10 100');
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(' '), code1 = input, code2 = '', num1, num2;
		try {
			if(i != -1) {
				code1 = input.substring(0, i);
				code2 = input.substring(i+1, input.length);
			}
			for(let id in network.ID_Registry) {
				if(i == -1) {
					num1 = eval(getDynamicSampleCode(input));
					num2 = num1;
				} else {
					num1 = eval(getDynamicSampleCode(code1));
					num2 = eval(getDynamicSampleCode(code2));
				}
				network.peers[id].latency = Math.max(0, rnd(num1, num2))
				for(let id2 in network.peers[id].outgoingPeers) {
					network.peers[id].outgoingPeers[id2] = Math.max(0, rnd(num1, num2));
				}
				try {
					// Set the first outgoing peer connection latency to the global latency
					network.peers[id].outgoingPeers[Object.keys(network.peers[id].outgoingPeers)[0]] = network.peers[id].latency;
				} catch(e) {}
			}
			updateMinerJsonEditor();
			DOM_setOptionMsg('SUCCESS', 'network', 'badge-success');
		} catch(e) {
			console.log('Setting latency code:', code1, code2);
			alert('Error: ' + e + '\n\nSee console for more information');
			console.log('Setting latency error:', e);
			DOM_setOptionMsg('UNSUCCESSFUL', 'network', 'badge-error');
		}
	}

	function DOM_globalSetDownloadMBPS() {
		DOM_clearOptionMsg();
		const input = prompt('You are about to set the network downlink megabytes per second of every miner in the network.\n\n• Enter one expression to set everyone\'s download rate the same.\n• Enter two expressions (separated by a space) to set the download rate randomly between a range.', '0.5 10');
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(' '), code1 = input, code2 = '', num1, num2;
		try {
			if(i != -1) {
				code1 = input.substring(0, i);
				code2 = input.substring(i+1, input.length);
			}
			for(let id in network.ID_Registry) {
				if(i == -1) {
					num1 = eval(getDynamicSampleCode(input));
					num2 = num1;
				} else {
					num1 = eval(getDynamicSampleCode(code1));
					num2 = eval(getDynamicSampleCode(code2));
				}
				network.peers[id].bandwidth.downlink = Math.max(0, rnd(num1, num2))
			}
			updateMinerJsonEditor();
			DOM_setOptionMsg('SUCCESS', 'network', 'badge-success');
		} catch(e) {
			console.log('Setting download rate code:', code1, code2);
			alert('Error: ' + e + '\n\nSee console for more information');
			console.log('Setting download rate error:', e);
			DOM_setOptionMsg('UNSUCCESSFUL', 'network', 'badge-error');
		}
	}

	function DOM_globalSetUploadMBPS() {
		DOM_clearOptionMsg();
		const input = prompt('You are about to set the network uplink megabytes per second of every miner in the network.\n\n• Enter one expression to set everyone\'s upload rate the same.\n• Enter two expressions (separated by a space) to set the upload rate randomly between a range.', '0.5 10');
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(' '), code1 = input, code2 = '', num1, num2;
		try {
			if(i != -1) {
				code1 = input.substring(0, i);
				code2 = input.substring(i+1, input.length);
			}
			for(let id in network.ID_Registry) {
				if(i == -1) {
					num1 = eval(getDynamicSampleCode(input));
					num2 = num1;
				} else {
					num1 = eval(getDynamicSampleCode(code1));
					num2 = eval(getDynamicSampleCode(code2));
				}
				network.peers[id].bandwidth.uplink = Math.max(0, rnd(num1, num2))
			}
			updateMinerJsonEditor();
			DOM_setOptionMsg('SUCCESS', 'network', 'badge-success');
		} catch(e) {
			console.log('Setting upload rate code:', code1, code2);
			alert('Error: ' + e + '\n\nSee console for more information');
			console.log('Setting upload rate error:', e);
			DOM_setOptionMsg('UNSUCCESSFUL', 'network', 'badge-error');
		}
	}

	function DOM_addMiner() {
		$('#addMinerName').val(fixCase($('#addMinerName').val()));
		const name = fixCase($('#addMinerName').val());
		const power = parseFloat($('#addMinerPower').val());
		const latency = parseFloat($('#addMinerLatency').val());
		const downlinkMBPS = parseFloat($('#addMinerDownloadMBPS').val());
		const uplinkMBPS = parseFloat($('#addMinerUploadMBPS').val());
		const peers = $('#multiselectAddPeers').val();
		let miner = newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, false);
		if(miner === undefined) {
			// The same name exists, check if any options have changed, otherwise edit the miner
			miner = network.findPeerByName(name);
			if(miner.power == power && miner.latency == latency && miner.bandwidth.downlink == downlinkMBPS && miner.bandwidth.uplink == uplinkMBPS) {
				let noChanges = true;
				for(let id of peers) {
					if(miner.ID == id) continue;
					if(miner.outgoingPeers[id] === undefined) {
						noChanges = false;
						break;
					}
				}
				for(let id in miner.outgoingPeers) {
					if(miner.ID == id) continue;
					if(!peers.includes(id)) {
						noChanges = false;
						break;
					}
				}
				if(noChanges) {
					DOM_setOptionMsg('NO CHANGES MADE', 'network', 'badge-primary');
					return;
				}
			}
			miner.power = power;
			miner.latency = latency;
			miner.bandwidth.downlink = downlinkMBPS;
			miner.bandwidth.uplink = uplinkMBPS;
			for(let id in miner.outgoingPeers) {
				miner.removeConnection(id);
			}
			for(let id of peers) {
				if(miner.outgoingPeers[id] === undefined) {
					miner.addConnection(id);
				}
			}
			DOM_setOptionMsg('EDITED ' + miner.name.toUpperCase(), 'network', 'badge-success');
		} else {
			for(let id of peers) {
				if(miner.outgoingPeers[id] === undefined) {
					miner.addConnection(id);
				}
			}
			DOM_setOptionMsg('ADDED ' + miner.name.toUpperCase(), 'network', 'badge-success');
		}
	}

	function DOM_removeMiner() {
		const e = $('#minerList option:selected');
		const miner = network.peers[e.val()];
		if(miner === undefined) {
			DOM_setOptionMsg('NO MINER SELECTED', 'network', 'badge-warning');
			return;
		}
		const name = miner.name;
		if(miner === undefined) {
			DOM_setOptionMsg('NO MINER SELECTED', 'network', 'badge-warning');
		} else {
			miner.destructor();
			delete network.peers[e.val()];
			e.remove();
			$('#removeMinerBtn').text('Remove miner');
			$('#toggleMinerMiningBtn').text('Toggle mining for miner');
			DOM_setOptionMsg('REMOVED ' + miner.name.toUpperCase(), 'network', 'badge-success');
		}
	}

	function DOM_removeAllMiners() {
		removeAllMiners();
		$('#minerList').empty();
		$('#removeMinerBtn').text('Remove miner');
		$('#toggleMinerMiningBtn').text('Toggle mining for miner');
		DOM_setOptionMsg('SUCCESS', 'network', 'badge-success');
	}

	function removeAllMiners() {
		for(let id in network.ID_Registry) {
			network.peers[id].destructor();
		}
		network.peers = {};
		network.ID_Registry = {};
	}

	function DOM_sortMiners() {
		const options = $('#minerList option');
		options.sort(function(a, b) {
			if (a.text.toUpperCase() > b.text.toUpperCase()) return 1;
			else if (a.text.toUpperCase() < b.text.toUpperCase()) return -1;
			else return 0;
		});
		$('#minerList').empty().append(options);
		DOM_setOptionMsg('SUCCESS', 'network', 'badge-success');
	}

	// Duplicates the current network to create two instances of it
	function duplicateTopology() {
		if(!confirm('You are about to duplicate your topology, the number of peers will double.\n\nContinue?')) return;
		let minerNames = ['Aaron', 'Adam', 'Alan', 'Albert', 'Alex', 'Alice', 'Andrew', 'Anthony', 'Arthur', 'Austin', 'Ben', 'Bill', 'Bob', 'Bobby', 'Brandon', 'Brian', 'Bruce', 'Carl', 'Charles', 'Chris', 'Dan', 'Daniel', 'David', 'Dennis', 'Donald', 'Douglas', 'Dylan', 'Edward', 'Eric', 'Ethan', 'Eugene', 'Frank', 'Gabriel', 'Gary', 'George', 'Gerald', 'Gregory', 'Harold', 'Harry', 'Henry', 'Jack', 'Jacob', 'James', 'Jason', 'Jeffrey', 'Jeremy', 'Jerry', 'Jesse', 'Joe', 'John', 'Johnny', 'Jonathan', 'Jordan', 'Jose', 'Joseph', 'Joshua', 'Juan', 'Justin', 'Keith', 'Kenneth', 'Kevin', 'Kyle', 'Larry', 'Lawrence', 'Logan', 'Louis', 'Mark', 'Matthew', 'Michael', 'Nathan', 'Nicholas', 'Noah', 'Patrick', 'Paul', 'Peter', 'Philip', 'Ralph', 'Randy', 'Raymond', 'Richard', 'Robert', 'Roger', 'Ronald', 'Roy', 'Russell', 'Ryan', 'Samuel', 'Scott', 'Sean', 'Stephen', 'Steven', 'Terry', 'Thomas', 'Timothy', 'Tyler', 'Vincent', 'Walter', 'Wayne', 'Will', 'Zachary'];
		shuffleArray(minerNames);
		try {
			if(network.peers[Object.keys(network.ID_Registry)[0]].name.length == 1) {
				minerNames = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
			}
		} catch(e) {}

		let translation = {};

		for(let peerID in network.peers) {
			let peer = network.peers[peerID];
			let newName = minerNames[0];
			for(let name of minerNames) {
				if(network.findPeerByName(name) == null) {
					newName = name;
					break;
				}
			}
			let miner = newMiner(newName, peer.power, peer.latency, peer.bandwidth.downlink, peer.bandwidth.uplink, true);
			translation[peer.ID] = miner.ID;
		}
		for(let peerID in translation) {
			let peer = network.peers[peerID];
			let newPeer = network.peers[translation[peerID]];
			for(let outgoingPeer in peer.outgoingPeers) {
				outgoingPeersTranslation = translation[outgoingPeer];

				if(outgoingPeersTranslation === undefined) continue;
				newPeer.addConnection(outgoingPeersTranslation);
			}
		}
		DOM_setOptionMsg('DUPLICATED', 'topology', 'badge-info');
	}

	function DOM_toggleLoggingNetworkData(override) {
		if(override !== undefined) network.logging.logNetworkData = !override;
		if(network.logging.logNetworkData) {
			network.logging.logNetworkData = false;
			$('#DOM_item_toggleLoggingNetworkData').html('Enable logging network<br>data within each miner');
			if(network) for(peerID in network.peers) { // Clean up
				delete network.peers[peerID]['blockchain_blockID'];
				delete network.peers[peerID]['blockchain_numHops'];
				delete network.peers[peerID]['blockchain_blockDelay'];
				delete network.peers[peerID]['blockchain_artificialBlockDelay'];
			}
		} else {
			$('#DOM_item_toggleLoggingNetworkData').html('Disable logging network<br>data within each miner');
			if(network) for(peerID in network.peers) { // Initialization
				network.peers[peerID]['blockchain_blockID'] = [];
				network.peers[peerID]['blockchain_numHops'] = [];
				network.peers[peerID]['blockchain_blockDelay'] = []
				network.peers[peerID]['blockchain_artificialBlockDelay'] = []
			}
			network.logging.logNetworkData = true;
		}
		updateMinerJsonEditor();
		saveSamplerSettings();
		loadSamplerSettings(); // To show/hide the parameters from the log columns list
		DOM_setOptionMsg('SUCCESS', 'network', 'badge-success');
	}

	// Refresh the full network data viewer
	function DOM_viewNetworkJSON() {
		networkjsoneditor.set(network);
	}

	function DOM_editMiner() {
		network.stopAllMiners();
		const miner = jsoneditor.get();
		if(miner === undefined) {
			$('#editMinerBadge').attr('class', 'ml-auto badge badge-danger');
			$('#editMinerBadge').text('NO DATA');
		} else if(miner.ID === undefined) {
			$('#editMinerBadge').attr('class', 'ml-auto badge badge-danger');
			$('#editMinerBadge').text('MINER NOT FOUND');
		} else if(network.peers[miner.ID] === undefined) {
			$('#editMinerBadge').attr('class', 'ml-auto badge badge-warning');
			$('#editMinerBadge').text('ID NOT FOUND');
		} else if(typeof miner.power != 'number' || typeof miner.latency != 'number' || typeof miner.bandwidth.downlink != 'number' || typeof miner.bandwidth.uplink != 'number') {
			// Type checking
			$('#editMinerBadge').attr('class', 'ml-auto badge badge-danger');
			$('#editMinerBadge').text('MUST BE A NUMBER');
		} else {
			// Merge the changes into the peer, excluding the current header
			miner.currentHeader = network.peers[miner.ID].currentHeader;
			miner.lastAcceptedBlock = network.peers[miner.ID].lastAcceptedBlock;
			miner.networkBuffer = network.peers[miner.ID].networkBuffer;
			Object.assign(network.peers[miner.ID], miner);
			
			$('#minerList  option[value="' + miner.ID + '"]').text(miner.name);
			$('#editMinerBadge').attr('class', 'ml-auto badge badge-primary');
			$('#editMinerBadge').text('SUCCESSFULLY SAVED');

			// Check for a latency update, if this happens we can update each link's latency
			let oldLatency = updateToolOptions.nodeLatencyBackup[miner.ID];
			if(oldLatency !== miner.latency) {
				for(let id in miner.outgoingPeers) {
					miner.outgoingPeers[id] = miner.latency;
				}
				updateToolOptions.nodeLatencyBackup[miner.ID] = miner.latency;
				updateMinerJsonEditor(miner.id);
				$('#editMinerBadge').text('UPDATED LATENCY');
			}
		}
	}

	// TODO: Enable editing the network directly
	function DOM_editNetwork() {
		/*const newNetwork = networkjsoneditor.get();
		if(newNetwork === undefined) {
			$('#editNetworkBadge').attr('class', 'ml-auto badge badge-danger');
			$('#editNetworkBadge').text('ERROR');
		} else {
			// Merge the changes into the peer, excluding the current header
			Object.assign(network, newNetwork);
			$('#editNetworkBadge').attr('class', 'ml-auto badge badge-primary');
			$('#editNetworkBadge').text('SUCCESSFULLY SAVED');
		}*/
		$('#editNetworkBadge').attr('class', 'ml-auto badge badge-warning');
		$('#editNetworkBadge').text('NOT SAVED');
	}

	function DOM_selectTopology(topology) {
		DOM_clearOptionMsg();
		$('#topologyTitle').text(topology + ' Topology');
		let options = {};
		switch(topology) {
			case 'Ring':
				options = {
					'Type': topology,
					'Bidirectional': false,
					'Number of peers': 10,
					'Minimum power (hashes per second)': 5,
					'Maximum power (hashes per second)': 10,
					'Minimum downlink (megabytes per second)': Infinity,
					'Maximum downlink (megabytes per second)': Infinity,
					'Minimum uplink (megabytes per second)': Infinity,
					'Maximum uplink (megabytes per second)': Infinity,
					'Minimum latency (milliseconds)': 100,
					'Maximum latency (milliseconds)': 100,
					'Naming cycle': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
				};
				break;
			case 'Mesh':
				options = {
					'Type': 'Mesh',
					'Bidirectional': true,
					'Prevent duplicate connections': true,
					'Number of peers': 30,
					'Minimum number of outgoing connections': 1,
					'Maximum number of outgoing connections': 1,
					'Minimum power (hashes per second)': 1,
					'Maximum power (hashes per second)': 5,
					'Minimum downlink (megabytes per second)': Infinity,
					'Maximum downlink (megabytes per second)': Infinity,
					'Minimum uplink (megabytes per second)': Infinity,
					'Maximum uplink (megabytes per second)': Infinity,
					'Minimum latency (milliseconds)': 100,
					'Maximum latency (milliseconds)': 100,
					'Naming cycle': ['Aaron', 'Adam', 'Alan', 'Albert', 'Alex', 'Alice', 'Andrew', 'Anthony', 'Arthur', 'Austin', 'Ben', 'Bill', 'Bob', 'Bobby', 'Brandon', 'Brian', 'Bruce', 'Carl', 'Charles', 'Chris', 'Dan', 'Daniel', 'David', 'Dennis', 'Donald', 'Douglas', 'Dylan', 'Edward', 'Eric', 'Ethan', 'Eugene', 'Frank', 'Gabriel', 'Gary', 'George', 'Gerald', 'Gregory', 'Harold', 'Harry', 'Henry', 'Jack', 'Jacob', 'James', 'Jason', 'Jeffrey', 'Jeremy', 'Jerry', 'Jesse', 'Joe', 'John', 'Johnny', 'Jonathan', 'Jordan', 'Jose', 'Joseph', 'Joshua', 'Juan', 'Justin', 'Keith', 'Kenneth', 'Kevin', 'Kyle', 'Larry', 'Lawrence', 'Logan', 'Louis', 'Mark', 'Matthew', 'Michael', 'Nathan', 'Nicholas', 'Noah', 'Patrick', 'Paul', 'Peter', 'Philip', 'Ralph', 'Randy', 'Raymond', 'Richard', 'Robert', 'Roger', 'Ronald', 'Roy', 'Russell', 'Ryan', 'Samuel', 'Scott', 'Sean', 'Stephen', 'Steven', 'Terry', 'Thomas', 'Timothy', 'Tyler', 'Vincent', 'Walter', 'Wayne', 'Will', 'Zachary']
				};
				break;
			case 'Star':
				options = {
					'Type': topology,
					'Bidirectional': true,
					'Towards center (if bidirectional=false)': true,
					'Number of peers': 6,
					'Minimum power (hashes per second)': 5,
					'Maximum power (hashes per second)': 10,
					'Minimum downlink (megabytes per second)': Infinity,
					'Maximum downlink (megabytes per second)': Infinity,
					'Minimum uplink (megabytes per second)': Infinity,
					'Maximum uplink (megabytes per second)': Infinity,
					'Minimum latency (milliseconds)': 100,
					'Maximum latency (milliseconds)': 100,
					'Naming cycle': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
				};
				break;
			case 'Fully Connected':
				options = {
					'Type': topology,
					'Number of peers': 4,
					'Minimum power (hashes per second)': 5,
					'Maximum power (hashes per second)': 10,
					'Minimum downlink (megabytes per second)': Infinity,
					'Maximum downlink (megabytes per second)': Infinity,
					'Minimum uplink (megabytes per second)': Infinity,
					'Maximum uplink (megabytes per second)': Infinity,
					'Minimum latency (milliseconds)': 100,
					'Maximum latency (milliseconds)': 100,
					'Naming cycle': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
				};
				break;
			case 'Line':
				options = {
					'Type': topology,
					'Bidirectional': true,
					'Number of peers': 6,
					'Minimum power (hashes per second)': 5,
					'Maximum power (hashes per second)': 10,
					'Minimum downlink (megabytes per second)': Infinity,
					'Maximum downlink (megabytes per second)': Infinity,
					'Minimum uplink (megabytes per second)': Infinity,
					'Maximum uplink (megabytes per second)': Infinity,
					'Minimum latency (milliseconds)': 100,
					'Maximum latency (milliseconds)': 100,
					'Naming cycle': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
				};
				break;
			case 'Tree':
				options = {
					'Type': topology,
					'Bidirectional': true,
					'Structure': [[[],[],[]],[[],[],[]],[[],[],[]]],
					'Minimum power (hashes per second)': 5,
					'Maximum power (hashes per second)': 10,
					'Minimum downlink (megabytes per second)': Infinity,
					'Maximum downlink (megabytes per second)': Infinity,
					'Minimum uplink (megabytes per second)': Infinity,
					'Maximum uplink (megabytes per second)': Infinity,
					'Minimum latency (milliseconds)': 100,
					'Maximum latency (milliseconds)': 100,
					'Naming cycle': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
				};
				break;
			case 'Bus':
				options = {
					'Type': topology,
					'Number of peers': 4,
					'Minimum power (hashes per second)': 5,
					'Maximum power (hashes per second)': 10,
					'Minimum downlink (megabytes per second)': Infinity,
					'Maximum downlink (megabytes per second)': Infinity,
					'Minimum uplink (megabytes per second)': Infinity,
					'Maximum uplink (megabytes per second)': Infinity,
					'Minimum latency (milliseconds)': 100,
					'Maximum latency (milliseconds)': 100,
					'Naming cycle': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
				};
				break;

			case 'Barabási-Albert':
				alert('Please be aware that this feature is still under development.')
				options = {
					'Type': topology,
					'Number of peers': 10,
					'Initial edges, m0': 1,
					'Edges, m': 1,
					'Minimum power (hashes per second)': 5,
					'Maximum power (hashes per second)': 10,
					'Minimum downlink (megabytes per second)': Infinity,
					'Maximum downlink (megabytes per second)': Infinity,
					'Minimum uplink (megabytes per second)': Infinity,
					'Maximum uplink (megabytes per second)': Infinity,
					'Minimum latency (milliseconds)': 100,
					'Maximum latency (milliseconds)': 100,
					'Naming cycle': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
				};
				break;


			case 'Bitcoin':
				options = {
					'Type': topology,
					'Number of peers': 1000,
					'Number of outgoing connections': 10,
					'Minimum power (hashes per second)': 1,
					'Maximum power (hashes per second)': 1,
					// https://www.statista.com/statistics/896779/average-mobile-fixed-broadband-download-upload-speeds
					'Minimum downlink (megabytes per second)': 84.33,
					'Maximum downlink (megabytes per second)': 84.33,
					'Minimum uplink (megabytes per second)': 44.1,
					'Maximum uplink (megabytes per second)': 44.1,
					// Recorded average latency of every public node in Bitcoin as of 04/01/2021
					'Latency distribution URL': 'data/bitcoin_latencies/bitcoin_latencies_removed_1_percentile.csv',
					'Naming cycle': ['Node ']
				};
				break;
			default:
				return;
		}
		topologyjsoneditor.set(options);

	}

	function DOM_generateTopology() {
		DOM_clearOptionMsg();
		try {
			// Do an extra check to disable the network visualizer if it may be too computationally taxing
			let json = topologyjsoneditor.get();
			if(json['Number of peers'] !== undefined && json['Type'] != 'Bitcoin') { // The Bitcoin topology automatically disables the visualizer
				numPeers = parseInt(json['Number of peers']) || 0;
				if(numPeers >= 50 && updateToolOptions.visSimulationActive) {
					let disableNetworkVisualizer  = confirm(`You are generating ${numPeers} nodes. Would you like to disable the network visualizer for an increase in performance?`);
					if(disableNetworkVisualizer) {
						toggleVisualizations();
					}
				}
			}

			generateTopology(json);
			$('#minerList option:first').prop('selected', true);
			$('#minerList option:first').change();
			updateTools();
			DOM_setOptionMsg('GENERATED', 'topology', 'badge-info');
		} catch(e) {
			console.error(e);
			alert(e + '\nSee console for more information.');
			return;
		}
	}

	function generateTopology(options, verbose = true) {
		if(verbose) console.log('Generate topology called:\n\ngenerateTopology(' + JSON_stringify(options) + ')');
		removeAllMiners();
		let promise = null;
		let miners, chosenNames, bidirectional, nPeers, minPower, maxPower, minLatency, maxLatency, names, minNumConnections, maxNumConnections, structure;
		switch(options['Type']) {
			case 'Ring':
				bidirectional = !!options['Bidirectional'];
				nPeers = options['Number of peers'] ?? 6;
				minPower = options['Minimum power (hashes per second)'] ?? 5;
				maxPower = options['Maximum power (hashes per second)'] ?? 10;
				minDownlinkMBPS = options['Minimum downlink (megabytes per second)'] ?? Infinity;
				maxDownlinkMBPS = options['Maximum downlink (megabytes per second)'] ?? Infinity;
				minUplinkMBPS = options['Minimum uplink (megabytes per second)'] ?? Infinity;
				maxUplinkMBPS = options['Maximum uplink (megabytes per second)'] ?? Infinity;
				minLatency = options['Minimum latency (milliseconds)'] ?? 100;
				maxLatency = options['Maximum latency (milliseconds)'] ?? 100;
				names = options['Naming cycle'] ?? ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(nPeers > names.length) name += '1';
					if(chosenNames[name] !== undefined) {
						let count = 2;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downlinkMBPS = rnd(minDownlinkMBPS, maxDownlinkMBPS);
					let uplinkMBPS = rnd(minUplinkMBPS, maxUplinkMBPS);
					miners.push(newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, true));
				}
				for(let i = 0; i < miners.length - 1; i++) {
					miners[i].addConnection(miners[i + 1].ID);
					if(bidirectional) miners[i + 1].addConnection(miners[i].ID);
				}
				miners[miners.length - 1].addConnection(miners[0].ID);
				if(bidirectional) miners[0].addConnection(miners[miners.length - 1].ID);
				break;

			case 'Mesh':
				minNumConnections = options['Minimum number of outgoing connections'] ?? 1;
				maxNumConnections = options['Maximum number of outgoing connections'] ?? 1;
				bidirectional = !!options['Bidirectional'];
				preventDuplicateConnections = !!options['Prevent duplicate connections'];
				nPeers = options['Number of peers'] ?? 6;
				minPower = options['Minimum power (hashes per second)'] ?? 5;
				maxPower = options['Maximum power (hashes per second)'] ?? 10;
				minDownlinkMBPS = options['Minimum downlink (megabytes per second)'] ?? Infinity;
				maxDownlinkMBPS = options['Maximum downlink (megabytes per second)'] ?? Infinity;
				minUplinkMBPS = options['Minimum uplink (megabytes per second)'] ?? Infinity;
				maxUplinkMBPS = options['Maximum uplink (megabytes per second)'] ?? Infinity;
				minLatency = options['Minimum latency (milliseconds)'] ?? 100;
				maxLatency = options['Maximum latency (milliseconds)'] ?? 100;
				names = options['Naming cycle'] ?? ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(nPeers > names.length) name += '1';
					if(chosenNames[name] !== undefined) {
						let count = 2;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downlinkMBPS = rnd(minDownlinkMBPS, maxDownlinkMBPS);
					let uplinkMBPS = rnd(minUplinkMBPS, maxUplinkMBPS);
					miners.push(newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, true));
				}
				for(let i = 0; i < miners.length; i++) {
					let nConnections = rnd(minNumConnections, maxNumConnections);
					for(let j = 0; j < nConnections; j++) {
						let r = rnd(0, miners.length - 1);
						// Attempt to connect to a unique connections at most 10 times
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);

						if(preventDuplicateConnections && (miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined)) continue;

						miners[i].addConnection(miners[r].ID);
						if(bidirectional) miners[r].addConnection(miners[i].ID);
					}
				}
				break;

			case 'Star':
				towardsCenter = !!options['Towards center (if bidirectional=false)'];
				bidirectional = !!options['Bidirectional'];
				nPeers = options['Number of peers'] ?? 6;
				minPower = options['Minimum power (hashes per second)'] ?? 5;
				maxPower = options['Maximum power (hashes per second)'] ?? 10;
				minDownlinkMBPS = options['Minimum downlink (megabytes per second)'] ?? Infinity;
				maxDownlinkMBPS = options['Maximum downlink (megabytes per second)'] ?? Infinity;
				minUplinkMBPS = options['Minimum uplink (megabytes per second)'] ?? Infinity;
				maxUplinkMBPS = options['Maximum uplink (megabytes per second)'] ?? Infinity;
				minLatency = options['Minimum latency (milliseconds)'] ?? 100;
				maxLatency = options['Maximum latency (milliseconds)'] ?? 100;
				names = options['Naming cycle'] ?? ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(nPeers > names.length) name += '1';
					if(chosenNames[name] !== undefined) {
						let count = 2;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downlinkMBPS = rnd(minDownlinkMBPS, maxDownlinkMBPS);
					let uplinkMBPS = rnd(minUplinkMBPS, maxUplinkMBPS);
					miners.push(newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, true));
				}
				if(bidirectional) {
					for(let i = 1; i < miners.length; i++) {
						miners[i].addConnection(miners[0].ID);
						miners[0].addConnection(miners[i].ID);
					}
				} else if(towardsCenter) {
					for(let i = 1; i < miners.length; i++) {
						miners[i].addConnection(miners[0].ID);
					}
				} else {
					for(let i = 1; i < miners.length; i++) {
						miners[0].addConnection(miners[i].ID);
					}
				}
				break;

			case 'Fully Connected':
				nPeers = options['Number of peers'] ?? 4;
				minPower = options['Minimum power (hashes per second)'] ?? 5;
				maxPower = options['Maximum power (hashes per second)'] ?? 10;
				minDownlinkMBPS = options['Minimum downlink (megabytes per second)'] ?? Infinity;
				maxDownlinkMBPS = options['Maximum downlink (megabytes per second)'] ?? Infinity;
				minUplinkMBPS = options['Minimum uplink (megabytes per second)'] ?? Infinity;
				maxUplinkMBPS = options['Maximum uplink (megabytes per second)'] ?? Infinity;
				minLatency = options['Minimum latency (milliseconds)'] ?? 100;
				maxLatency = options['Maximum latency (milliseconds)'] ?? 100;
				names = options['Naming cycle'] ?? ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(nPeers > names.length) name += '1';
					if(chosenNames[name] !== undefined) {
						let count = 2;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downlinkMBPS = rnd(minDownlinkMBPS, maxDownlinkMBPS);
					let uplinkMBPS = rnd(minUplinkMBPS, maxUplinkMBPS);
					miners.push(newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, true));
				}
				for(let i = 0; i < miners.length; i++) {
					for(let j = 0; j < miners.length; j++) {
						miners[i].addConnection(miners[j].ID);
						miners[j].addConnection(miners[i].ID);
					}
				}
				break;

			case 'Line':
				bidirectional = !!options['Bidirectional'];
				nPeers = options['Number of peers'] ?? 6;
				minPower = options['Minimum power (hashes per second)'] ?? 5;
				maxPower = options['Maximum power (hashes per second)'] ?? 10;
				minDownlinkMBPS = options['Minimum downlink (megabytes per second)'] ?? Infinity;
				maxDownlinkMBPS = options['Maximum downlink (megabytes per second)'] ?? Infinity;
				minUplinkMBPS = options['Minimum uplink (megabytes per second)'] ?? Infinity;
				maxUplinkMBPS = options['Maximum uplink (megabytes per second)'] ?? Infinity;
				minLatency = options['Minimum latency (milliseconds)'] ?? 100;
				maxLatency = options['Maximum latency (milliseconds)'] ?? 100;
				names = options['Naming cycle'] ?? ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(nPeers > names.length) name += '1';
					if(chosenNames[name] !== undefined) {
						let count = 2;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downlinkMBPS = rnd(minDownlinkMBPS, maxDownlinkMBPS);
					let uplinkMBPS = rnd(minUplinkMBPS, maxUplinkMBPS);
					miners.push(newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, true));
				}
				for(let i = 0; i < miners.length - 1; i++) {
					miners[i].addConnection(miners[i + 1].ID);
					if(bidirectional) miners[i + 1].addConnection(miners[i].ID);
				}
				break;

			case 'Tree':
				bidirectional = !!options['Bidirectional'];
				structure = options['Structure'];
				minPower = options['Minimum power (hashes per second)'] ?? 5;
				maxPower = options['Maximum power (hashes per second)'] ?? 10;
				minDownlinkMBPS = options['Minimum downlink (megabytes per second)'] ?? Infinity;
				maxDownlinkMBPS = options['Maximum downlink (megabytes per second)'] ?? Infinity;
				minUplinkMBPS = options['Minimum uplink (megabytes per second)'] ?? Infinity;
				maxUplinkMBPS = options['Maximum uplink (megabytes per second)'] ?? Infinity;
				minLatency = options['Minimum latency (milliseconds)'] ?? 100;
				maxLatency = options['Maximum latency (milliseconds)'] ?? 100;
				names = options['Naming cycle'] ?? ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
				chosenNames = [];
				let i = 0;
				nPeers = recursivelyCountTreeTopology(structure);
				recursivelyGenerateTreeTopology(structure, nPeers, null);

				// Count the number of items in a structure (including the base directories)
				function recursivelyCountTreeTopology(structure) {
					let count = 1;
					for(let child of structure) {
						count += recursivelyCountTreeTopology(child);
					}
					return count;
				}

				// Generate the tree topology
				function recursivelyGenerateTreeTopology(structure, nPeers, parent) {
					let name = names[i % names.length];
					if(nPeers > names.length) name += '1';
					if(chosenNames[name] !== undefined) {
						let count = 2;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downlinkMBPS = rnd(minDownlinkMBPS, maxDownlinkMBPS);
					let uplinkMBPS = rnd(minUplinkMBPS, maxUplinkMBPS);
					let miner = newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, true);
					if(parent != null) {
						if(bidirectional) {
							miner.addConnection(parent.ID);
							parent.addConnection(miner.ID);
						} else {
							miner.addConnection(parent.ID);
						}
					}
					for(let child of structure) {
						i++;
						recursivelyGenerateTreeTopology(child, nPeers, miner, i);
					}
				}
				break;

			case 'Bus':
				nPeers = options['Number of peers'] ?? 4;
				minPower = options['Minimum power (hashes per second)'] ?? 5;
				maxPower = options['Maximum power (hashes per second)'] ?? 10;
				minDownlinkMBPS = options['Minimum downlink (megabytes per second)'] ?? Infinity;
				maxDownlinkMBPS = options['Maximum downlink (megabytes per second)'] ?? Infinity;
				minUplinkMBPS = options['Minimum uplink (megabytes per second)'] ?? Infinity;
				maxUplinkMBPS = options['Maximum uplink (megabytes per second)'] ?? Infinity;
				minLatency = options['Minimum latency (milliseconds)'] ?? 100;
				maxLatency = options['Maximum latency (milliseconds)'] ?? 100;
				names = options['Naming cycle'] ?? ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(nPeers > names.length) name += '1';
					if(chosenNames[name] !== undefined) {
						let count = 2;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downlinkMBPS = rnd(minDownlinkMBPS, maxDownlinkMBPS);
					let uplinkMBPS = rnd(minUplinkMBPS, maxUplinkMBPS);
					miners.push(newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, true));
				}
				for(let i = 0; i < miners.length; i++) {
					for(let j = 0; j < miners.length; j++) {
						miners[i].addConnection(miners[j].ID);
						miners[j].addConnection(miners[i].ID);
					}
				}
				break;

			case 'Barabási-Albert':

				nPeers = options['Number of peers'] ?? 20;
				m0 = options['Initial edges, m0'] ?? 1;
				m = options['Edges, m'] ?? 1;
				minPower = options['Minimum power (hashes per second)'] ?? 5;
				maxPower = options['Maximum power (hashes per second)'] ?? 10;
				minDownlinkMBPS = options['Minimum downlink (megabytes per second)'] ?? Infinity;
				maxDownlinkMBPS = options['Maximum downlink (megabytes per second)'] ?? Infinity;
				minUplinkMBPS = options['Minimum uplink (megabytes per second)'] ?? Infinity;
				maxUplinkMBPS = options['Maximum uplink (megabytes per second)'] ?? Infinity;
				minLatency = options['Minimum latency (milliseconds)'] ?? 100;
				maxLatency = options['Maximum latency (milliseconds)'] ?? 100;
				names = options['Naming cycle'] ?? ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
				
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(nPeers > names.length) name += '1';
					if(chosenNames[name] !== undefined) {
						let count = 2;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downlinkMBPS = rnd(minDownlinkMBPS, maxDownlinkMBPS);
					let uplinkMBPS = rnd(minUplinkMBPS, maxUplinkMBPS);
					miners.push(newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, true));
				}

				// Add the initial m0 connections
				if(miners.length > 0) {
					for(let i = 0; i < m0; i++) {
						let r = rnd(0, miners.length - 1);
						// Attempt to connect to a unique connections at most 10 times
						if(miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
						if(miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);

						if(preventDuplicateConnections && (miners[0].ID == miners[r].ID || miners[0].outgoingPeers[miners[r].ID] !== undefined)) continue;

						miners[0].addConnection(miners[r].ID);
					}
				}

				// Todo:
				for(let i = 0; i < miners.length; i++) {
					sumEdges = 0
					connCount = 0
					for(let j = 0; j < i; j++) {
						let numEdges = network.peers[miners[j].ID].incomingPeers.length;
						sumEdges += numEdges;

						let p = numEdges / sumEdges;

						if(Math.random() < p) {
							miners[i].addConnection(miners[j].ID);
							connCount++;
							if(connCount >= m) break;
						}
					}
					if(i > 0 && miners[i].outgoingPeers[miners[i - 1].ID] === undefined) {
						miners[i].addConnection(miners[i - 1].ID);
					}
				}
				miners[miners.length - 1].addConnection(miners[0].ID);
				if(bidirectional) miners[0].addConnection(miners[miners.length - 1].ID);
				break;



			case 'Bitcoin':
				nPeers = options['Number of peers'] ?? 100;
				numConnections = options['Number of outgoing connections'] ?? 10;
				bidirectional = true;
				preventDuplicateConnections = true;
				minPower = options['Minimum power (hashes per second)'] ?? 5;
				maxPower = options['Maximum power (hashes per second)'] ?? 10;
				minDownlinkMBPS = options['Minimum downlink (megabytes per second)'] ?? Infinity;
				maxDownlinkMBPS = options['Maximum downlink (megabytes per second)'] ?? Infinity;
				minUplinkMBPS = options['Minimum uplink (megabytes per second)'] ?? Infinity;
				maxUplinkMBPS = options['Maximum uplink (megabytes per second)'] ?? Infinity;
				latencyUrl = options['Latency distribution URL'] ?? 'data/bitcoin_latencies/bitcoin_latencies.csv';
				names = options['Naming cycle'] ?? ['Node '];

				if(updateToolOptions.visSimulationActive) {
					console.info('Disabling the topology visualizer for improved performance. This can be re-enabled under "Display" --> "Toggle visualizations".');
					toggleVisualizations();
				}

				const gen = () => {
					miners = [];
					chosenNames = [];
					for(let i = 0; i < nPeers; i++) {
						let name = names[i % names.length];
						if(nPeers > names.length) name += '1';
						if(chosenNames[name] !== undefined) {
							let count = 2;
							do {
								name = names[i % names.length] + count.toString();
								count++;
							} while(chosenNames[name] !== undefined);
						}
						chosenNames[name] = true;
						let power = rnd(minPower, maxPower);
						let latency = 0;
						let downlinkMBPS = rnd(minDownlinkMBPS, maxDownlinkMBPS);
						let uplinkMBPS = rnd(minUplinkMBPS, maxUplinkMBPS);
						miners.push(newMiner(name, power, latency, downlinkMBPS, uplinkMBPS, true));
					}
					for(let i = 0; i < miners.length; i++) {
						for(let j = 0; j < numConnections; j++) {
							let r = rnd(0, miners.length - 1);
							// Attempt to connect to a unique connections at most 10 times
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined) r = rnd(0, miners.length - 1);

							if(preventDuplicateConnections && (miners[i].ID == miners[r].ID || miners[i].outgoingPeers[miners[r].ID] !== undefined)) continue;

							miners[i].addConnection(miners[r].ID);
							if(bidirectional) miners[r].addConnection(miners[i].ID);
						}
					}
					randomizeLatenciesFromBitnodes(latencyUrl);
				}

				// Dynamically fetch the URL files, and cache them in updateToolOptions for later use
				if(latencyUrl != updateToolOptions.bitcoinLatencyData.url) {
					promise = openAndReadFile(latencyUrl).then(latencies => {
						let latencyArray = CSVToArray(latencies);
						if(latencyArray.length < 2) {
							console.warn('Unable to find the URL CSV latency data. Using global average latency as backup.');
							updateToolOptions.bitcoinLatencyData.url = latencyUrl;
							updateToolOptions.bitcoinLatencyData.data = [['Global average', 259.1934515]]; // If issue fetching file, use the hardcoded average latency of the network (as of 07/20/21)
						} else {
							// Remove the CSV headers
							latencyArray.shift();
							updateToolOptions.bitcoinLatencyData.url = latencyUrl;
							updateToolOptions.bitcoinLatencyData.data = latencyArray;
						}
						gen();
					});
				} else gen();
				break;

			default:
				DOM_setOptionMsg('UNEXPECTED TOPOLOGY', 'network', 'badge-danger');
		}
		DOM_selectedMiner();

		// Create a blank promise that resolves instantly
		if(promise == null) promise = Promise.resolve();
		return promise;
	}

	// Reset every node's current latency, replacing it from the randomized data in Bitcoin's latency distribution dataset provided by Bitnodes
	function randomizeLatenciesFromBitnodes(latencyUrl = 'data/bitcoin_latencies/bitcoin_latencies_removed_1_percentile.csv') {
		let promise, gen = () => {
			for(let id in network.ID_Registry) {
				// Pick a random latency from the real-world Bitcoin distribution data
				let latency = updateToolOptions.bitcoinLatencyData.data[Math.floor(Math.random() * updateToolOptions.bitcoinLatencyData.data.length)][1]; // Second column in the CSV file

				// The following line accomodates for the round-trip nature of the real-world data, since ping and pong from nodes N1 and N2 with latencies L1 and L2, respectively, require two times the latency: L1 --> L2 --> L1
				latency = latency / 2;

				network.peers[id].latency = latency;
				for(let id2 in network.peers[id].outgoingPeers) {
					// Pick a random latency from the real-world Bitcoin distribution data
					let latency = updateToolOptions.bitcoinLatencyData.data[Math.floor(Math.random() * updateToolOptions.bitcoinLatencyData.data.length)][1]; // Second column in the CSV file

					// The following line accomodates for the round-trip nature of the real-world data, since ping and pong from nodes N1 and N2 with latencies L1 and L2, respectively, require two times the latency: L1 --> L2 --> L1
					latency = latency / 2;

					network.peers[id].outgoingPeers[id2] = latency;
				}
				try {
					// Attempt to set the node's latency to be the same as the first outgoing connection's latency
					network.peers[id].latency = network.peers[id].outgoingPeers[Object.keys(network.peers[id].outgoingPeers)[0]];
				} catch(e) {}
			}
			console.log('Latencies have been set using the Bitnodes dataset.');
		}

		// Dynamically fetch the URL files, and cache them in updateToolOptions for later use
		if(latencyUrl != updateToolOptions.bitcoinLatencyData.url) {
			promise = openAndReadFile(latencyUrl).then(latencies => {
				let latencyArray = CSVToArray(latencies);
				if(latencyArray.length < 2) {
					console.warn('Unable to find the URL CSV latency data. Using global average latency as backup.');
					updateToolOptions.bitcoinLatencyData.url = latencyUrl;
					updateToolOptions.bitcoinLatencyData.data = [['Global average', 409.91]]; // Average hardcoded latency of the network
				} else {
					// Remove the CSV headers
					latencyArray.shift();
					updateToolOptions.bitcoinLatencyData.url = latencyUrl;
					updateToolOptions.bitcoinLatencyData.data = latencyArray;
				}
				gen();
			});
		} else gen();
		return promise;
	}

	// Check if an object is a promise
	function isPromise(promise) {
		return !!promise && typeof promise.then === 'function';
	}

	function DOM_setNetworkDifficulty() {
		const difficulty = prompt('Enter a network difficulty threshold in hex, or in decimal (as the probability of finding a block).\n\nEasiest difficulty = 1.0 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', network.difficulty);
		if(difficulty == null) return;
		network.setDifficulty(difficulty);
		alert('Difficulty has been set to ' + network.difficulty * 100 + '% chance of a nonce being a block.');
	}

	function toggleSha256() {
		if(network.useSHA256) {
			network.useSHA256 = false;
			$('#useSHA256Btn').text('Use secure SHA-256 (slower)');
			alert('Using real security (SHA-256) has been disabled.');
		} else {
			network.useSHA256 = true;
			$('#useSHA256Btn').text('Use fast block verification');
			alert('Using real security (SHA-256) has been enabled.');
		}
	}

	function DOM_setBlockSizes() {
		try {
			const blockSize = prompt('Enter a block size in bytes', network.blockSize);
			let size = parseInt(blockSize);
			if(size > 0) {
				network.blockSize = size;
				alert('The block size has been updated to ' + size + ' bytes.');
			}
		} catch(e) {}
	}

	function DOM_setOptionMsg(msg, topic = 'file', style = 'badge-success') {
		if(topic == 'file') {
			$('#fileOptionMsg').attr('class', 'badge ' + style);
			$('#fileOptionMsg').text(msg);

		} else if(topic == 'network') {
			$('#networkOptionMsg').attr('class', 'badge ' + style);
			$('#networkOptionMsg').text(msg);

		} else if(topic == 'topology') {
			$('#topologyOptionMsg').attr('class', 'badge ' + style);
			$('#topologyOptionMsg').text(msg);

		} else if(topic == 'display') {
			$('#displayOptionMsg').attr('class', 'badge ' + style);
			$('#displayOptionMsg').text(msg);
		}
	}

	function DOM_clearOptionMsg() {
		$('#fileOptionMsg').attr('class', 'badge badge-success');
		$('#fileOptionMsg').text('');
		$('#networkOptionMsg').attr('class', 'badge badge-success');
		$('#networkOptionMsg').text('');
		$('#topologyOptionMsg').attr('class', 'badge badge-success');
		$('#topologyOptionMsg').text('');
		$('#displayOptionMsg').attr('class', 'badge badge-success');
		$('#displayOptionMsg').text('');
	}

	function DOM_toggleMining() {
		const e = $('#minerList option:selected');
		const miner = network.peers[e.val()];
		if(miner === undefined) {
			DOM_setOptionMsg('NO MINER SELECTED', 'network', 'badge-warning');
		} else {
			if(network.miningThreads[miner.ID] !== undefined) {
				miner.stopMining();
			} else {
				miner.startMining();
				$('#toggleMiningBtn').text('Stop All Miners');
				if(updateToolOptions.visSimulationActive) startCanvasVisualizerThread();
			}
		}
	}

	function DOM_toggleAllMining() {
		if($('#toggleMiningBtn').text() == 'Start All Miners') {
			$('#toggleMiningBtn').text('Stop All Miners');
			network.startAllMiners();
			if(updateToolOptions.visSimulationActive) startCanvasVisualizerThread();
			$('#toggleMiningBtn').attr('class', 'btn btn-warning rounded-0 border border-top-0 border-dark');
		} else {
			$('#toggleMiningBtn').text('Start All Miners');
			network.stopAllMiners();
			stopCanvasVisualizerThread();
			$('#toggleMiningBtn').attr('class', 'btn btn-dark rounded-0');
		}
	}

	function DOM_toggleMinerStatsTable() {
		let minerStatsDiv = document.getElementById('minerStatsDiv');
		if(updateToolOptions.minerStatsTable_active) {
			updateToolOptions.minerStatsTable_active = false;
			$('#minerStatsTable').html('');
			$('#minerStatsDiv').hide();
		} else {
			updateToolOptions.minerStatsTable_active = true;
			updateMinerStatsTable();
			$('#minerStatsDiv').show();
		}
	}

	function updateMinerStatsTable() {
		if(!updateToolOptions.minerStatsTable_active) return;

		let html = '<thead>';
		html += '<th scope="col"><button onclick="updateMinerStatsTable()" class="btn btn-secondary">Refresh</button></th>';
		html += '<th scope="col">Account balance</th>';
		html += '<th scope="col" class="text-warning">%</th>';
		html += '<th scope="col">Power (H/s)</th>';
		html += '<th scope="col" class="text-warning">%</th>';

		if(network.logging.logNetworkData) {
			html += '<th scope="col">Block num hops</th>';
			html += '<th scope="col">Block travel time</th>';
		}
		html += '<th scope="col">Blocks in flight</th>';

		html += '<th scope="col">Latency (ms)</th>';
		html += '<th scope="col">Downlink (MBps)</th>';
		html += '<th scope="col">Uplink (MBps)</th>';
		html += '<th scope="col">In peers</th>';
		html += '<th scope="col">Out peers</th>';
		html += '<th scope="col">Block height</th>';
		html += '<th scope="col">Total blocks</th>';
		html += '<th scope="col">Stale blocks</th>';
		html += '<th scope="col">Max fork length</th>';
		html += '</thead>';
		html += '<tbody>';
		let sum = {
			power: 0,
			numHops: 0,
			blockDelay: 0,
			artificialBlockDelay: 0,
			blocksInFlight: 0,
			latency: 0,
			downlinkMBPS: 0,
			uplinkMBPS: 0,
			balance: 0,
			incomingPeers: 0,
			outgoingPeers: 0,
			height: 0,
			totalBlocksFound: 0,
			staleBlocksFound: 0,
			largestForkLength: 0,
		}
		let avg = {
			power: 0,
			numHops: 0,
			blockDelay: 0,
			artificialBlockDelay: 0,
			blocksInFlight: 0,
			latency: 0,
			downlinkMBPS: 0,
			uplinkMBPS: 0,
			balance: 0,
			incomingPeers: 0,
			outgoingPeers: 0,
			height: 0,
			totalBlocksFound: 0,
			staleBlocksFound: 0,
			largestForkLength: 0,
		}
		let numPeers = 0;
		for(let id in network.ID_Registry) {
			let miner = network.peers[id];
			sum.power += miner.power;

			if(network.logging.logNetworkData) { // Keep track of networking data
				try {
					let numHopsAvg = miner.blockchain_numHops.reduce((a, b) => a + b) / miner.blockchain_numHops.length;
					let blockDelayAvg = miner.blockchain_blockDelay.reduce((a, b) => a + b) / miner.blockchain_blockDelay.length;
					let artificialBlockDelayAvg = miner.blockchain_artificialBlockDelay.reduce((a, b) => a + b) / miner.blockchain_artificialBlockDelay.length;
					sum.numHops += numHopsAvg;
					sum.blockDelay += blockDelayAvg;
					sum.artificialBlockDelay += artificialBlockDelayAvg;
				} catch(e) {}
			}

			sum.blocksInFlight += miner.networkBuffer.buffer.length;
			sum.latency += miner.latency;
			sum.downlinkMBPS += miner.bandwidth.downlink;
			sum.uplinkMBPS += miner.bandwidth.uplink;
			sum.balance += (miner.currentHeader.balances[id] - 1); // "- 1" because the most recent header contains a coinbase transaction not yet confirmed, since the currentHeader is not a valid block yet
			sum.incomingPeers += miner.incomingPeers.length;
			sum.outgoingPeers += Object.keys(miner.outgoingPeers).length;
			sum.height += (miner.currentHeader.height - 1); // Same reason as above
			sum.totalBlocksFound += miner.totalBlocksFound;
			sum.staleBlocksFound += miner.staleBlocksFound;
			sum.largestForkLength += miner.largestForkLength;
			numPeers++;
		}
		avg.power = Math.floor(sum.power / numPeers * 1000) / 1000;
		if(network.logging.logNetworkData) { // Keep track of networking data
			avg.numHops = Math.floor(sum.numHops / numPeers * 1000) / 1000;
			avg.blockDelay = Math.floor(sum.blockDelay / numPeers * 1000) / 1000;
		}
		avg.blocksInFlight = Math.floor(sum.blocksInFlight / numPeers * 1000) / 1000;
		avg.latency = Math.floor(sum.latency / numPeers * 1000) / 1000;
		avg.downlinkMBPS = Math.floor(sum.downlinkMBPS / numPeers * 1000) / 1000;
		avg.uplinkMBPS = Math.floor(sum.uplinkMBPS / numPeers * 1000) / 1000;
		avg.balance = Math.floor(sum.balance / numPeers * 1000) / 1000;
		avg.incomingPeers = Math.floor(sum.incomingPeers / numPeers * 1000) / 1000;
		avg.outgoingPeers = Math.floor(sum.outgoingPeers / numPeers * 1000) / 1000;
		avg.height = Math.floor(sum.height / numPeers * 1000) / 1000;
		avg.totalBlocksFound = Math.floor(sum.totalBlocksFound / numPeers * 1000) / 1000;
		avg.staleBlocksFound = Math.floor(sum.staleBlocksFound / numPeers * 1000) / 1000;
		avg.largestForkLength = Math.floor(sum.largestForkLength / numPeers * 1000) / 1000;
		for(let id in network.ID_Registry) {
			let miner = network.peers[id];
			html += '<tr onclick="selectMiner(\'' + miner.ID + '\')">';
			html += '<th scope="col">' + miner.name + '</th>';
			html += '<th scope="col">' + ((miner.currentHeader.balances[id] - 1) || 0) + '</th>';
			html += '<th scope="col" class="text-warning">' + ((Math.floor((miner.currentHeader.balances[id] - 1) / sum.balance * 100000) / 1000) || 0) + '</th>';
			html += '<th scope="col">' + miner.power + '</th>';
			if(sum.power == 0) {
				html += '<th scope="col" class="text-warning">-</th>';
			} else {
				html += '<th scope="col" class="text-warning">' + (Math.floor(miner.power / sum.power * 100000) / 1000) + '</th>';
			}

			if(network.logging.logNetworkData) { // Keep track of networking data
				try {
					let numHopsAvg = miner.blockchain_numHops.reduce((a, b) => a + b) / miner.blockchain_numHops.length;
					let blockDelayAvg = miner.blockchain_blockDelay.reduce((a, b) => a + b) / miner.blockchain_blockDelay.length;
					let artificialBlockDelayAvg = miner.blockchain_artificialBlockDelay.reduce((a, b) => a + b) / miner.blockchain_artificialBlockDelay.length;

					html += '<th scope="col">' + (Math.floor(numHopsAvg * 1000) / 1000) + '</th>';
					html += '<th scope="col">' + (Math.floor(blockDelayAvg * 1000) / 1000) + '</th>';
				} catch(e) {
					html += '<th scope="col">-</th>';
					html += '<th scope="col">-</th>';
				}
			}

			html += '<th scope="col">' + miner.networkBuffer.buffer.length + '</th>';
			html += '<th scope="col">' + miner.latency + '</th>';
			html += '<th scope="col">' + miner.bandwidth.downlink + '</th>';
			html += '<th scope="col">' + miner.bandwidth.uplink + '</th>';

			html += '<th scope="col">' + miner.incomingPeers.length + '</th>';
			html += '<th scope="col">' + Object.keys(miner.outgoingPeers).length + '</th>';
			html += '<th scope="col">' + (miner.currentHeader.height - 1) + '</th>';
			html += '<th scope="col">' + miner.totalBlocksFound + '</th>';
			html += '<th scope="col">' + miner.staleBlocksFound + '</th>';
			html += '<th scope="col">' + miner.largestForkLength + '</th>';
			html += '</tr>';
		}
		html += '<tr class="text-dark bg-light">';
		html += '<th scope="col">Sum<br>Average</th>';
		html += '<th scope="col">' + sum.balance + '<br>' + avg.balance + '</th>';
		html += '<th scope="col"></th>';
		html += '<th scope="col">' + sum.power + '<br>' + avg.power + '</th>';
		html += '<th scope="col"></th>';

		if(network.logging.logNetworkData) { // Keep track of networking data
			html += '<th scope="col">' + (Math.floor(sum.numHops * 1000) / 1000) + '<br>' + (Math.floor(avg.numHops * 1000) / 1000) + '</th>';
			html += '<th scope="col">' + (Math.floor(sum.blockDelay * 1000) / 1000) + '<br>' + (Math.floor(avg.blockDelay * 1000) / 1000) + '</th>';
		}

		html += '<th scope="col">' + sum.blocksInFlight + '<br>' + avg.blocksInFlight + '</th>';
		html += '<th scope="col">' + sum.latency + '<br>' + avg.latency + '</th>';
		html += '<th scope="col">' + sum.downlinkMBPS + '<br>' + avg.downlinkMBPS + '</th>';
		html += '<th scope="col">' + sum.uplinkMBPS + '<br>' + avg.uplinkMBPS + '</th>';
		html += '<th scope="col">' + sum.incomingPeers + '<br>' + avg.incomingPeers + '</th>';
		html += '<th scope="col">' + sum.outgoingPeers + '<br>' + avg.outgoingPeers + '</th>';
		html += '<th scope="col">' + sum.height + '<br>' + avg.height + '</th>';
		html += '<th scope="col">' + sum.totalBlocksFound + '<br>' + avg.totalBlocksFound + '</th>';
		html += '<th scope="col">' + sum.staleBlocksFound + '<br>' + avg.staleBlocksFound + '</th>';
		html += '<th scope="col">' + sum.largestForkLength + '<br>' + avg.largestForkLength + '</th>';
		html += '</tr>';

		html += '</tbody>';
		$('#minerStatsTable').html(html);
	}

	function toggleVisualizations() {
		let vis_container = document.getElementById('networkVisualizer');
		if(updateToolOptions.visSimulationActive) {
			updateToolOptions.visSimulationActive = false;
			vis_clearNetworkSimulation();
			$('#vis_refresh_btn').hide();
			$('#vis_line_length_btn').hide();
			$('#vis_btn_delimeter').hide();

			$('#canvasVisualizerContainer').hide();
			stopCanvasVisualizerThread();
			clearCanvasVisualizer();
		} else {
			updateToolOptions.visSimulationActive = true;
			updateToolOptions.visTimeout = null;
			vis_container.style.height = '500px';
			vis_container.style.opacity = '1';
			vis_setupNetworkSimulation();
			$('#vis_refresh_btn').show();
			$('#vis_line_length_btn').show();
			$('#vis_btn_delimeter').show();

			$('#canvasVisualizerContainer').show();
		}
	}

	// Draw the circles to the right of the canvas visualizer DOM element
	function drawCanvasVisualizerMinerCircles() {
		const canvas = document.getElementById('canvasVisualizer');
		const ctx = canvas.getContext('2d');
		let numPeers = Object.keys(network.peers).length;
		let barsize = Math.ceil(canvas.height / numPeers);
		let i = 0;
		ctx.clearRect(canvas.width - barsize * 1.5, 0, canvas.width, canvas.height);
		for(let id in network.peers) {
			let color = network.peers[id].color;
			let y = Math.floor(i * canvas.height / numPeers);
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.arc(canvas.width - barsize / 1.5, y + barsize / 2, Math.max(2, barsize / 2 - 1), 0, 2 * Math.PI);
			ctx.fill();

			if(id == updateToolOptions.selectedMiner) {
				ctx.fillStyle = '#000';
				ctx.beginPath();
				ctx.arc(canvas.width - barsize / 1.5, y + barsize / 2, Math.max(1, barsize / 2 - 4), 0, 2 * Math.PI);
				ctx.fill();
			}
			//ctx.fillRect(canvas.width - barsize, y, barsize, barsize); // Square instead of circle
			i++;
		}
	}

	// Initiate the canvas visualizer
	function setupCanvasVisualizer() {
		const canvas = document.getElementById('canvasVisualizer');
		canvas.width = $('#canvasVisualizer').width();
		canvas.height = Object.keys(network.peers).length * updateToolOptions.canvasVisualizerBarWidth;

		drawCanvasVisualizerMinerCircles();

		if($('#toggleMiningBtn').text().startsWith('Stop')) {
			startCanvasVisualizerThread();
		}
	}

	// When clicked, select the miner at the corresponding row
	function canvasVisualizerClicked(event) {
		let canvas = document.getElementById('canvasVisualizer');
		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;

		let minerIDs = Object.keys(network.peers);
		let numPeers = minerIDs.length;
		let barsize = Math.ceil(canvas.height / numPeers);
		let minerIndex = Math.floor(y / barsize);
		if(minerIndex < 0 || minerIndex >= numPeers) return;
		let miner = minerIDs[minerIndex];
		selectMiner(miner);
	}

	// Java's String#hashCode, used to select a color in the canvas visualizer
	function hashCode(str) {
		var hash = 0;
		for (var i = 0; i < str.length; i++) {
			hash = str.charCodeAt(i) + ((hash << 5) - hash);
		}
		return hash;
	}

	// Convert an integer into a color
	function intToRGB(i){
		var c = (i & 0x00FFFFFF).toString(16).toUpperCase();
		return '00000'.substring(0, 6 - c.length) + c;
	}

	function startCanvasVisualizerThread() {
		if(updateToolOptions.canvasVisualizerThread == null) {
			updateToolOptions.canvasVisualizerThread = setInterval(updateCanvasVisualizer, updateToolOptions.canvasVisualizerInterval);
		}
	}

	function stopCanvasVisualizerThread() {
		clearInterval(updateToolOptions.canvasVisualizerThread);
		updateToolOptions.canvasVisualizerThread = null;
	}

	function clearCanvasVisualizer() {
		const canvas = document.getElementById('canvasVisualizer');
		const ctx = canvas.getContext('2d');
		ctx.clearRect(0, 0, canvas.width, canvas.height);
	}

	function updateCanvasVisualizer() {
		if(updateToolOptions.visSimulationActive == false) {
			clearInterval(updateToolOptions.canvasVisualizerThread);
			updateToolOptions.canvasVisualizerThread = null;
			return;
		}

		let numPeers = Object.keys(network.peers).length;

		const code = network.logging.canvasVisualizerCode;
		const canvas = document.getElementById('canvasVisualizer');
		const ctx = canvas.getContext('2d');
		let barsize = Math.ceil(canvas.height / numPeers);
		let px = updateToolOptions.canvasVisualizerPixelStepSize ?? 1;

		imageData = ctx.getImageData(px, 0, canvas.width - px - Math.floor(barsize * 1.5), canvas.height);
		ctx.putImageData(imageData, 0, 0);
		ctx.clearRect(canvas.width - px - Math.floor(barsize * 1.5), 0, px, canvas.height);

		let i = 0;
		for(let id in network.peers) {
			let obj = '', str = '';
			try {
				let miner = network.peers[id];
				obj = eval(network.logging.canvasVisualizerCode) ?? '';
				str = JSON_stringify(obj);
			} catch(e) {}

			let color = intToRGB(hashCode(str));

			ctx.fillStyle = '#' + color;
			let y = Math.floor(i * canvas.height / numPeers);
			ctx.fillRect(canvas.width - px - Math.floor(barsize * 1.5), y, px, barsize);
			i++;
		}
	}

	function vis_clearNetworkSimulation() {
		let vis_container = document.getElementById('networkVisualizer');
		updateToolOptions.visNodeIDs = []
		updateToolOptions.visNetwork = new vis.Network(vis_container, {}, {});
		vis_container.innerHTML = '';
		vis_container.style.height = '0';
		vis_container.style.opacity = '0';
	}

	function DOM_togglePhysics() {
		let physics = !updateToolOptions.visNetwork.physics.options.enabled;
		if(physics) $('#vis_physics_btn').text('Disable visualizer physics');
		else $('#vis_physics_btn').text('Enable visualizer physics');
		updateToolOptions.visNetwork.physics.setOptions({'enabled': physics});
	}

	function DOM_setLineLengths() {
		let length_s = prompt('How long should lines be?', updateToolOptions.visLineLength);
		if(length_s == null) return;
		let length = parseInt(length_s) || undefined;

		updateToolOptions.visLineLength = length;
		vis_setupNetworkSimulation();
		DOM_setOptionMsg('SUCCESS', 'display', 'badge-success');
	}

	function DOM_setBarWidths() {
		let width_s = prompt('How long should lines be?', updateToolOptions.canvasVisualizerBarWidth);
		if(width_s == null) return;
		let width = parseInt(width_s) || undefined;

		updateToolOptions.canvasVisualizerBarWidth = width;
		setupCanvasVisualizer();
		DOM_setOptionMsg('SUCCESS', 'display', 'badge-success');

		
	}

	function DOM_refreshVisualizer() {
		vis_setupNetworkSimulation();
		DOM_setOptionMsg('REFRESHED', 'display', 'badge-info');
	}

	function requestVisRedraw() {
		if(!updateToolOptions.visSimulationActive) return;
		if(updateToolOptions.requestVisRedrawTimeout != null) return;
		updateToolOptions.requestVisRedrawTimeout = setTimeout(_requestVisRedraw, 1000 / 30);
	}

	function _requestVisRedraw() {
		updateToolOptions.visNetwork.redraw();
		updateToolOptions.requestVisRedrawTimeout = null;
	}

	function vis_setupNetworkSimulation() {
		// Wait a minimum time before allowing the next simulation setup
		if(updateToolOptions.visTimeout != null) return;
		updateToolOptions.visTimeout = setTimeout(_vis_setupNetworkSimulation, 510);
	}

	function _vis_setupNetworkSimulation() {
		updateToolOptions.visNodeIDs = []
		let vis_nodes = [], vis_edges = [], i = 0;
		for(let id in network.ID_Registry) {
			updateToolOptions.visNodeIDs[id] = i;
			vis_nodes.push({
				id: updateToolOptions.visNodeIDs[id],
				label: network.peers[id].name,
				group: i,
				color: network.peers[id].color == 'default' ? undefined : network.peers[id].color,
			});
			i++;
		}

		for(let id1 in network.ID_Registry) {
			for(let id2 in network.peers[id1].outgoingPeers) {
				vis_edges.push({
					from: updateToolOptions.visNodeIDs[id1],
					to: updateToolOptions.visNodeIDs[id2],
					length: updateToolOptions.visLineLength,
					// Optionally add dashes to lines that are not bi-directional connections:
					// dashes: network.peers[id2].outgoingPeers[id1] !== undefined ? false : [10, 10],
				});
			}
		}
		let vis_container = document.getElementById('networkVisualizer');

		updateToolOptions.vis_network_options = {
			nodes: {
				shape: 'dot',
				size: 30,
				font: {
					size: 32,
					color: '#FFF'
				},
				borderWidth: 4,
			},
			edges: {
				width: 6
			},
			layout: {
				improvedLayout: true
			},
			interaction: {
				dragView: false,
				selectConnectedEdges: false,
				zoomView: false,
				dragNodes: false
			},
			physics: {
				enabled: true
			}
		};

		updateToolOptions.visNetwork = new vis.Network(vis_container, {
			nodes: vis_nodes,
			edges: vis_edges
		}, updateToolOptions.vis_network_options);

		// Retrieve the node color from the vis.js datastructure
		let visRawNodeData = updateToolOptions.visNetwork.nodesHandler.body.nodes;
		let style = '';
		for(let id in updateToolOptions.visNodeIDs) {
			try {
				let vis_rawNode = visRawNodeData[updateToolOptions.visNodeIDs[id]];
				let color = vis_rawNode.options.color.background;
				network.peers[id].color = color;
				style += `#minerList option:checked[value="${id}"]{border-right:22px solid ${color};padding-left:10px}`;
			} catch(e) {}
		}
		document.getElementById('miner-colors-selector').innerHTML = style;

		updateMinerJsonEditor();

		updateToolOptions.visNetwork.on('selectNode', function (params) {
			let miner, minerID;
			for(let id in updateToolOptions.visNodeIDs) {
				if(updateToolOptions.visNodeIDs[id] == params.nodes[0]) {
					minerID = id;
				}
			}
			selectMiner(minerID, false);
		});

		updateToolOptions.visNetwork.view.canvas.frame.addEventListener('focus', function() {
			let option = {
				interaction: {
					zoomView: true,
					dragNodes: true
				}
			};
			updateToolOptions.visNetwork.setOptions(option);
		});
		updateToolOptions.visNetwork.view.canvas.frame.addEventListener('blur', function() {
			let option = {
				interaction: {
					zoomView: false,
					dragNodes: false
				}
			};
			updateToolOptions.visNetwork.setOptions(option);
		});

		updateToolOptions.visNetwork.on('zoom', function (e) {
			let pos = updateToolOptions.visNetwork.getViewPosition();
			let scale = Math.max(0.1, Math.min(10, updateToolOptions.visNetwork.getScale()));
			updateToolOptions.visNetwork.moveTo({
				position: { x: 0, y: 0},
				scale: scale,
			});
			// Adjust the border according to scale
			if(scale <= 0.15) {
				if(updateToolOptions.visBorderSize != 'none') {
					vis_setBorders(0);
					updateToolOptions.visBorderSize = 'none';
				}
			}else if(scale < 0.4) {
				if(updateToolOptions.visBorderSize != 'small') {
					vis_setBorders(1);
					updateToolOptions.visBorderSize = 'small';
				}
			} else if(scale > 1.5) {
				if(updateToolOptions.visBorderSize != 'large') {
					vis_setBorders(13);
					updateToolOptions.visBorderSize = 'large';
				}
			} else {
				if(updateToolOptions.visBorderSize) {
					vis_setBorders(4);
					updateToolOptions.visBorderSize = 'default';
				}
			}
		});
		updateToolOptions.visTimeout = null;

		setupCanvasVisualizer();
	}

	function vis_setBorders(width = 4) {
		if(!updateToolOptions.visSimulationActive) return;
		for(let ID in network.peers) {
			let visID = updateToolOptions.visNodeIDs[ID];
			let visRawNodeData = updateToolOptions.visNetwork.nodesHandler.body.nodes[visID];
			if(visRawNodeData === undefined) continue;
			if(visRawNodeData.globalOptions.borderWidth == width) return;

			visRawNodeData.globalOptions.borderWidth = width;
		}
	}

	// Save the code from the DOM to the network data
	function saveSamplerSettings() {
		clearTimeout(updateToolOptions.saveSamplerSettingsTimeout);
		updateToolOptions.saveSamplerSettingsTimeout = setTimeout(_saveSamplerSettings, 300);
	}

	// Called at a maximum of once every second, responsible for taking in all the DOM data and saving the sampler values into the network object
	function _saveSamplerSettings() {
		network.logging.msPerSample = Math.floor(Number($('#timePerSample').val()) * 1000);

		// Add the code wrapper
		let _code = 'let numSamples = updateToolOptions.numSamples, samplerData = updateToolOptions.samplerData;\nfunction setTag(tag) {\n\tupdateToolOptions.sampleTag = tag.toString();\n}\n\n';

		network.logging.codeBeforeSampling = '{\n' + _code + updateToolOptions.codeEditorBeforeSampling.getValue() + '\n}';
		network.logging.codeBetweenSamples = '{\n' + _code + updateToolOptions.codeEditorBetweenSamples.getValue() + '\n}';
		network.logging.codeAfterSampling = '{\n' + _code + updateToolOptions.codeEditorAfterSampling.getValue() + '\n}';

		network.logging.logSamples = $('#logSamplesCheckbox').prop('checked');
		network.logging.resetBlockchainAfterEachSample = $('#resetBlockchainAfterEachSampleCheckbox').prop('checked');
		network.logging.updateTableAfterEachSample = $('#updateTableAfterEachSampleCheckbox').prop('checked');

		// Update the list of log columns
		let columns = $('#logColumnsList').val();
		for(let column in network.logging.columns) {
			network.logging.columns[column] = false;
		}
		for(let column of columns) {
			network.logging.columns[column] = true;
		}

		if(network.logging.logSamples) {
			if($('#logColumns').is(':hidden')) {
				$('#logColumns').show();
				scrollToBottomOfPage();
			} else $('#logColumns').show();
		} else $('#logColumns').hide();

		network.logging.canvasVisualizerCode = '{' + $('#canvasVisualizerCode').val() + '}';
	}

	// Load the code from the network to the DOM
	function loadSamplerSettings() {
		$('#timePerSample').val(network.logging.msPerSample / 1000);

		// Remove the code wrapper
		let _code = 'let numSamples = updateToolOptions.numSamples, samplerData = updateToolOptions.samplerData;\nfunction setTag(tag) {\n\tupdateToolOptions.sampleTag = tag.toString();\n}\n\n';

		let codeBeforeSampling = network.logging.codeBeforeSampling;
		let codeBetweenSamples = network.logging.codeBetweenSamples;
		let codeAfterSampling = network.logging.codeAfterSampling;

		if(codeBeforeSampling.startsWith('{\n')) codeBeforeSampling = codeBeforeSampling.substring(2);
		if(codeBetweenSamples.startsWith('{\n')) codeBetweenSamples = codeBetweenSamples.substring(2);
		if(codeAfterSampling.startsWith('{\n')) codeAfterSampling = codeAfterSampling.substring(2);

		if(codeBeforeSampling.startsWith(_code)) codeBeforeSampling = codeBeforeSampling.substring(_code.length);
		if(codeBetweenSamples.startsWith(_code)) codeBetweenSamples = codeBetweenSamples.substring(_code.length);
		if(codeAfterSampling.startsWith(_code)) codeAfterSampling = codeAfterSampling.substring(_code.length);

		if(codeBeforeSampling.endsWith('\n}')) codeBeforeSampling = codeBeforeSampling.slice(0, -2);
		if(codeBetweenSamples.endsWith('\n}')) codeBetweenSamples = codeBetweenSamples.slice(0, -2);
		if(codeAfterSampling.endsWith('\n}')) codeAfterSampling = codeAfterSampling.slice(0, -2);

		updateToolOptions.codeEditorBeforeSampling.setValue(codeBeforeSampling);
		updateToolOptions.codeEditorBetweenSamples.setValue(codeBetweenSamples);
		updateToolOptions.codeEditorAfterSampling.setValue(codeAfterSampling);

		$('#logSamplesCheckbox').prop('checked', network.logging.logSamples);
		$('#resetBlockchainAfterEachSampleCheckbox').prop('checked', network.logging.resetBlockchainAfterEachSample);
		$('#updateTableAfterEachSampleCheckbox').prop('checked', network.logging.updateTableAfterEachSample);

		$('#logColumnsList').empty();
		for(let column in network.logging.columns) {

			let hideIfNetworkLoggingNotEnabled = '';
			// If the network logging parameters are disabled, hide it from the list as well
			if(!network.logging.logNetworkData) {
				if(column == 'Blockchain IDs' || column == 'Blockchain num hops' || column == 'Blockchain travel time (ms)' || column == 'Artificial travel time (ms)') {
					hideIfNetworkLoggingNotEnabled = ' hidden';
				}
			}

			$('#logColumnsList').append('<option value="' + column + '"' + hideIfNetworkLoggingNotEnabled + '>' + column + '</option>');
			$('#logColumnsList option[value="' + column + '"]').prop('selected', network.logging.columns[column]);
		}
		if(network.logging.logSamples) $('#logColumns').show();
		else $('#logColumns').hide();

		// Canvas visualizer code
		let canvasVisualizerCode = network.logging.canvasVisualizerCode;
		if(canvasVisualizerCode.startsWith('{')) canvasVisualizerCode = canvasVisualizerCode.substring(1);
		if(canvasVisualizerCode.endsWith('}')) canvasVisualizerCode = canvasVisualizerCode.slice(0, -1);
		$('#canvasVisualizerCode').val(canvasVisualizerCode);
	}

	function DOM_toggleSamplerForm() {
		if(updateToolOptions.sampler_DOM_active) {
			$('#samplerDiv').hide();
			updateToolOptions.sampler_DOM_active = false;
		} else {
			$('#samplerDiv').show();
			updateToolOptions.sampler_DOM_active = true;
		}
	}

	function toggleSampling(override) {
		if(override !== undefined) updateToolOptions.sampler_running = !override;
		if(updateToolOptions.sampler_running) {
			stopSampling();
			noSleep.disable();
			$('#toggleSamplingBtn').text('Begin Sampling');
			$('#toggleSamplingBtn').attr('class', 'btn btn-primary fillx border border-dark');
			updateToolOptions.sampler_running = false;
			updateSamplerTable();
		} else {
			initSampler();
			noSleep.enable(); // Prevent the browser from falling asleep
			$('#toggleSamplingBtn').text('Stop Sampling');
			$('#toggleSamplingBtn').attr('class', 'btn btn-warning fillx border border-dark');
			updateToolOptions.sampler_running = true;
			network.startAllMiners();
			updateToolOptions.sampleStartTime = new Date().getTime();
			setTimeout(sample, network.logging.msPerSample);
		}
	}

	function registerSamplerForId(id) {
		updateToolOptions.samplerData[id] = {
			sumBalance: 0,
			sumPower: 0,
			sumNumHops: 0,
			sumBlockDelay: 0,
			sumArtificialBlockDelay: 0,
			sumBlocksInFlight: 0,
			sumLatency: 0,
			sumDownloadMBPS: 0,
			sumUploadMBPS: 0,
			sumBlockHeight: 0,
			sumTotalBlocks: 0,
			sumStaleBlocks: 0,
			sumMaxForkLength: 0,
		}
	}

	// Given a code with miner IDs referenced by the user, convert it into executable JavaScript by inserting the network.peers[] wrapper around code not surrounded by quotes
	function getDynamicSampleCode(code) {
		code = ' ' + code + ' ';
		let temp = extractQuotes(code);
		// Convert miner IDs into proper references
		let IDs = Object.keys(network.peers);
		IDs.sort(function(a, b){ // Process IDs from longest to shortest when replacing
			return b.length - a.length;
		});
		// The replacement is done in two phases
		// Phase 1: Create an intermediate string to avoid ID collisions, fill an array of replacements for phase 2
		let replace = []; // Keep a list of replacements
		for(let ID of IDs) {
			// Use a negative lookbehind and negative lookahead to ensure that the node ID is not part of a larger word
			let regex = new RegExp('(?<![0-9A-Za-z_])(' + ID + ')(?![0-9A-Za-z_])'), match;
			do {
				match = temp[0].match(regex);
				if(match != null) {
					let from = match[0], to = '${' + Math.random() + '}';
					temp[0] = temp[0].replace(from, to);
					replace.push([from, to]);
				}
			} while(match != null);
		}
		// Phase 2: Take the intermediate replacement data, and fill it with the final network.peers[ID] data
		for(let item of replace) {
			temp[0] = temp[0].replace(item[1], 'network.peers["' + item[0] + '"]');
		}
		return reinsertQuotes(temp).trim();
	}

	function initSampler() {
		if(updateToolOptions.visSimulationActive) {
			console.info('Disabling the topology visualizer for more precise measurements. This can be re-enabled under "Display" --> "Toggle visualizations".');
			toggleVisualizations();
		}
		if(updateToolOptions.minerStatsTable_active) {
			console.info('Disabling the miner stats table for improved performance. This can be re-enabled under "Display" --> "Toggle miner stats table".');
			DOM_toggleMinerStatsTable();
		}

		network.stopAllMiners();
		network.removeBlocksInFlight();
		network.clearBlockchain();

		updateToolOptions.numSamples = 0;
		updateToolOptions.samplerData = [];
		updateToolOptions.samplerLog = [''];
		updateToolOptions.sampleTag = '';

		if(network.logging.logSamples) {
			let html = '<button onclick="downloadSampleLog()" class="btn btn-warning fillx">Download log</button>';
			$('#sampleTable').html(html);
		}
		// Move the DOM textareas into the network logging code
		_saveSamplerSettings();

		network.logging.codeBeforeSampling = getDynamicSampleCode(network.logging.codeBeforeSampling);
		let promise = null;
		try { // Run the user code before samples
			promise = eval(network.logging.codeBeforeSampling);
		} catch(e) {
			alert(e);
			console.warn(e);
		}

		if(!isPromise(promise)) promise = Promise.resolve(); // Temp promise resolves immediately

		promise.then(() => {
			// Keep these three columns outside the peer for loop since they are static columns
			if(network.logging.columns['Sample']) updateToolOptions.samplerLog[0] += 'Sample,';
			if(network.logging.columns['Sample time']) updateToolOptions.samplerLog[0] += 'Sample time,';
			if(network.logging.columns['Sample tag']) updateToolOptions.samplerLog[0] += 'Sample tag,';

			for(let id in network.peers) {
				for(let column in network.logging.columns) {
					if(column == 'Sample') continue;
					if(column == 'Sample time') continue;
					if(column == 'Sample tag') continue;

					if(!network.logging.logNetworkData) {
						if(column == 'Blockchain IDs' || column == 'Blockchain num hops' || column == 'Blockchain travel time (ms)' || column == 'Artificial travel time (ms)') {
							continue;
						}
					}

					if(network.logging.columns[column]) {
						updateToolOptions.samplerLog[0] += column + ',';
					}
				}
				registerSamplerForId(id);
			}

			_saveSamplerSettings();
			network.logging.codeBeforeSampling = getDynamicSampleCode(network.logging.codeBeforeSampling);
			network.logging.codeBetweenSamples = getDynamicSampleCode(network.logging.codeBetweenSamples);
			network.logging.codeAfterSampling = getDynamicSampleCode(network.logging.codeAfterSampling);
		});
	}

	function sample() {
		updateToolOptions.sampleEndTime = new Date().getTime();

		if(network.logging.resetBlockchainAfterEachSample) {
			network.stopAllMiners();
		}

		let sampleDuration = (updateToolOptions.sampleEndTime - updateToolOptions.sampleStartTime) / 1000;
		updateToolOptions.numSamples++;
		for(let id in network.ID_Registry) {
			let miner = network.peers[id];
			if(updateToolOptions.samplerData[id] === undefined) {
				// If new nodes were added since the beginning of logging, include them in the samples
				registerSamplerForId(id);
			}
			updateToolOptions.samplerData[id].sumBalance += miner.currentHeader.balances[id];
			updateToolOptions.samplerData[id].sumPower += miner.power;

			if(network.logging.logNetworkData) {
				try {
					let numHopsAvg = miner.blockchain_numHops.reduce((a, b) => a + b) / miner.blockchain_numHops.length;
					let blockDelayAvg = miner.blockchain_blockDelay.reduce((a, b) => a + b) / miner.blockchain_blockDelay.length;
					let artificialBlockDelayAvg = miner.blockchain_artificialBlockDelay.reduce((a, b) => a + b) / miner.blockchain_artificialBlockDelay.length;
					updateToolOptions.samplerData[id].sumNumHops += numHopsAvg;
					updateToolOptions.samplerData[id].sumBlockDelay += blockDelayAvg;
					updateToolOptions.samplerData[id].sumArtificialBlockDelay += artificialBlockDelayAvg;
				} catch(e) {}
			}

			updateToolOptions.samplerData[id].sumLatency += miner.latency;
			updateToolOptions.samplerData[id].sumDownloadMBPS += miner.bandwidth.downlink;
			updateToolOptions.samplerData[id].sumUploadMBPS += miner.bandwidth.uplink;
			updateToolOptions.samplerData[id].sumBlockHeight += miner.currentHeader.height - 1;
			updateToolOptions.samplerData[id].sumTotalBlocks += miner.totalBlocksFound;
			updateToolOptions.samplerData[id].sumStaleBlocks += miner.staleBlocksFound;
			updateToolOptions.samplerData[id].sumMaxForkLength += miner.largestForkLength;
			updateToolOptions.samplerData[id].sumBlocksInFlight += miner.networkBuffer.buffer.length;
		}
		if(network.logging.logSamples) {
			let line = '', balanceTotal = 0, powerTotal = 0, latencyTotal = 0, downloadMBPSTotal = 0, uploadMBPSTotal = 0;
			if(network.logging.columns['Sample']) line += '"' + updateToolOptions.samplerLog.length + '",';
			if(network.logging.columns['Sample time']) line += '"' + sampleDuration + '",';
			if(network.logging.columns['Sample tag']) line += '"' + updateToolOptions.sampleTag + '",';

			for(let id in network.ID_Registry) {
				let miner = network.peers[id];
				balanceTotal += miner.currentHeader.balances[id];
				powerTotal += miner.power;
				latencyTotal += miner.latency;
				downloadMBPSTotal += miner.bandwidth.downlink;
				uploadMBPSTotal += miner.bandwidth.uplink;
			}
			for(let id in network.ID_Registry) {
				let miner = network.peers[id];

				if(network.logging.columns['Miner name']) line += '"' + miner.name + '",';
				if(network.logging.columns['Balance']) line += '"' + (miner.currentHeader.balances[id] || 0) + '",';
				if(network.logging.columns['Balance %']) line += '"' + ((miner.currentHeader.balances[id] / balanceTotal * 100) || 0) + '",';
				if(network.logging.columns['Power (hash/s)']) line += '"' + miner.power + '",';
				if(network.logging.columns['Power %']) line += '"' + (miner.power / powerTotal * 100) + '",';

				if(network.logging.logNetworkData) { // Keep track of networking data
					if(network.logging.columns['Blockchain IDs']) line += '"' + miner.blockchain_blockID?.join(' ') + '",';
					if(network.logging.columns['Blockchain num hops']) line += '"' + miner.blockchain_numHops?.join(' ') + '",';
					if(network.logging.columns['Blockchain travel time (ms)']) line += '"' + miner.blockchain_blockDelay?.join(' ') + '",';
					if(network.logging.columns['Artificial travel time (ms)']) line += '"' + miner.blockchain_artificialBlockDelay?.join(' ') + '",';
				}

				if(network.logging.columns['Network buffer size limit']) line += '"' + miner.networkBuffer.bufferSizeLimit + '",';
				if(network.logging.columns['Blocks in flight']) line += '"' + miner.networkBuffer.buffer.length + '",';
				if(network.logging.columns['Latency (ms)']) line += '"' + miner.latency + '",';
				if(network.logging.columns['Downlink (MBps)']) line += '"' + miner.bandwidth.downlink + '",';
				if(network.logging.columns['Uplink (MBps)']) line += '"' + miner.bandwidth.uplink + '",';
				if(network.logging.columns['Block height']) line += '"' + (miner.currentHeader.height - 1) + '",';
				if(network.logging.columns['Total blocks found']) line += '"' + miner.totalBlocksFound + '",';
				if(network.logging.columns['Stale blocks found']) line += '"' + miner.staleBlocksFound + '",';
				if(network.logging.columns['Max fork length']) line += '"' + (miner.largestForkLength || 0) + '",';
			}
			updateToolOptions.samplerLog.push(line);
		}
		if(network.logging.resetBlockchainAfterEachSample) {
			network.removeBlocksInFlight();
			network.clearBlockchain();
		}

		if(network.logging.updateTableAfterEachSample) {
			updateSamplerTable();
		}
		let promise = null;
		try {
			promise = eval(network.logging.codeBetweenSamples);
		} catch(e) {
			console.warn(e, network.logging.codeBetweenSamples);
		}

		if(!isPromise(promise)) promise = Promise.resolve(); // Temp promise resolves immediately

		promise.then(() => { // Support promises being resolved in the code
			if(network.logging.resetBlockchainAfterEachSample) {
				network.startAllMiners();
			}
			if(updateToolOptions.sampler_running) {
				updateToolOptions.sampleStartTime = new Date().getTime();
				setTimeout(sample, network.logging.msPerSample);
			}
		});
	}

	function stopSampling() {
		try {
			eval(network.logging.codeAfterSampling);
		} catch(e) {
			alert(e);
			console.warn(e);
		}
		network.stopAllMiners();
		network.removeBlocksInFlight();
		network.clearBlockchain();
	}

	function updateSamplerTable() {
		let sampleDuration = (updateToolOptions.sampleEndTime - updateToolOptions.sampleStartTime) / 1000;
		let html = '<thead>'
		if(updateToolOptions.samplerLog.length > 1) {
			html += '<th colspan="3"><button onclick="downloadSampleLog()" class="btn btn-warning fillx">Download log'
			// Display how many samples are logged, if it's different from the sample number (i.e. if samples were dynamically toggled during experiment)
			if(updateToolOptions.numSamples != updateToolOptions.samplerLog.length - 1) html += ' (' + (updateToolOptions.samplerLog.length - 1) + ')'
			html += '</button></th>';
		}
		html += '<th colspan="8"><span class="text-warning lead">' + updateToolOptions.numSamples + (updateToolOptions.numSamples == 1 ? ' sample' : ' samples') + ' taken'
		if(updateToolOptions.sampler_running) html += ' (' + sampleDuration + ' seconds)';
		if(updateToolOptions.sampleTag.length > 0) html += ' (' + updateToolOptions.sampleTag + ')';
		html += '</span>';
		html += '</thead><thead>';

		html += '<th scope="col" style="width:10%"></th>';
		html += '<th scope="col">Average<br>account balance</th>';
		html += '<th scope="col" class="text-warning">%</th>';
		html += '<th scope="col">Average<br>power (H/s)</th>';

		if(network.logging.logNetworkData) { // Keep track of networking data
			html += '<th scope="col">Average<br>block num hops</th>';
			html += '<th scope="col">Average<br>block travel time</th>';
			html += '<th scope="col">Average<br>artificial travel time</th>';
		}
		html += '<th scope="col">Average<br>blocks in flight</th>';

		html += '<th scope="col">Average<br>latency (ms)</th>';
		html += '<th scope="col">Average<br>download (MBps)</th>';
		html += '<th scope="col">Average<br>upload (MBps)</th>';
		html += '<th scope="col">Average<br>block height</th>';
		html += '<th scope="col">Average<br>total blocks found</th>';
		html += '<th scope="col">Average<br>stale blocks found</th>';
		html += '<th scope="col">Average<br>max fork length</th>';
		html += '</thead>';
		html += '<tbody>';
		let miner, avgSumBalance, percentAvgSumBalance, miners = 0, sumAvgSumBalance = 0, avgPower, avgNumHops, avgBlockDelay, avgArtificialBlockDelay, avgBlocksInFlight, avgLatency, avgDownloadMBPS, avgUploadMBPS, avgBlockHeight, avgTotalBlocks, avgStaleBlocks, avgMaxForkLength;

		for(let id in network.ID_Registry) {
			miners++;
			sumAvgSumBalance += updateToolOptions.samplerData[id].sumBalance / updateToolOptions.numSamples;
		}

		for(let id in network.ID_Registry) {
			miner = network.peers[id];
			avgSumBalance = Math.floor(updateToolOptions.samplerData[id].sumBalance / updateToolOptions.numSamples * 1000) / 1000;
			percentAvgSumBalance = Math.floor(avgSumBalance / sumAvgSumBalance * 100000) / 1000;
			avgPower = Math.floor(updateToolOptions.samplerData[id].sumPower / updateToolOptions.numSamples * 1000) / 1000;
			if(network.logging.logNetworkData) { // Keep track of networking data
				avgNumHops = Math.floor(updateToolOptions.samplerData[id].sumNumHops / updateToolOptions.numSamples * 1000) / 1000;
				avgBlockDelay = Math.floor(updateToolOptions.samplerData[id].sumBlockDelay / updateToolOptions.numSamples * 1000) / 1000;
				avgArtificialBlockDelay = Math.floor(updateToolOptions.samplerData[id].sumArtificialBlockDelay / updateToolOptions.numSamples * 1000) / 1000;
			}
			avgBlocksInFlight = Math.floor(updateToolOptions.samplerData[id].sumBlocksInFlight / updateToolOptions.numSamples * 1000) / 1000;
			avgLatency = Math.floor(updateToolOptions.samplerData[id].sumLatency / updateToolOptions.numSamples * 1000) / 1000;
			avgDownloadMBPS = Math.floor(updateToolOptions.samplerData[id].sumDownloadMBPS / updateToolOptions.numSamples * 1000) / 1000;
			avgUploadMBPS = Math.floor(updateToolOptions.samplerData[id].sumUploadMBPS / updateToolOptions.numSamples * 1000) / 1000;
			avgBlockHeight = Math.floor(updateToolOptions.samplerData[id].sumBlockHeight / updateToolOptions.numSamples * 1000) / 1000;
			avgTotalBlocks = Math.floor(updateToolOptions.samplerData[id].sumTotalBlocks / updateToolOptions.numSamples * 1000) / 1000;
			avgStaleBlocks = Math.floor(updateToolOptions.samplerData[id].sumStaleBlocks / updateToolOptions.numSamples * 1000) / 1000;
			avgMaxForkLength = Math.floor(updateToolOptions.samplerData[id].sumMaxForkLength / updateToolOptions.numSamples * 1000) / 1000;
			html += '<tr onclick="selectMiner(\'' + miner.ID + '\')">';
			html += '<th scope="col">' + miner.name + '</th>';
			html += '<th scope="col">' + (avgSumBalance || '-') + '</th>';
			html += '<th scope="col" class="text-warning">' + (percentAvgSumBalance || '-') + '</th>';
			html += '<th scope="col">' + (avgPower || '') + '</th>';

			if(network.logging.logNetworkData) { // Keep track of networking data
				html += '<th scope="col">' + (avgNumHops || '-') + '</th>';
				html += '<th scope="col">' + (avgBlockDelay || '-') + '</th>';
				html += '<th scope="col">' + (avgArtificialBlockDelay || '-') + '</th>';
			}
			html += '<th scope="col">' + (avgBlocksInFlight || '-') + '</th>';

			html += '<th scope="col">' + (avgLatency || '-') + '</th>';
			html += '<th scope="col">' + (avgDownloadMBPS || '-') + '</th>';
			html += '<th scope="col">' + (avgUploadMBPS || '-') + '</th>';
			html += '<th scope="col">' + (avgBlockHeight || '-') + '</th>';
			html += '<th scope="col">' + (avgTotalBlocks || '-') + '</th>';
			html += '<th scope="col">' + (avgStaleBlocks || '-') + '</th>';
			html += '<th scope="col">' + (avgMaxForkLength || '-') + '</th>';
			html += '</tr>';
		}
		html += '</tbody>';
		$('#sampleTable').html(html);
		if(updateToolOptions.minerStatsTable_active) updateMinerStatsTable();
	}

	// Download the list of CSV rows from updateToolOptions.samplerLog
	function downloadSampleLog(name) {
		if(name === undefined) {
			if(network.name == '') name = 'PoW_log.csv';
			else name = 'PoW_log_' + network.name.replace(/\s/g, '_') + '.csv';
		}
		let log = updateToolOptions.samplerLog.join('\r\n');
		let a = document.createElement('a');
		
		try {
			a.setAttribute('href','data:text/plain;charset=utf-8,' + encodeURIComponent(log));
		} catch (e) { // Plan B: If encodeURIComponent gives a RangeError, simply don't use it:
			console.log('\n\n\n\n\n\n\n\n\n\n');
			console.warn('The sample log filled up the browser\'s memory capacity. Now attempting to download it without encodeURIComponent...');
			
			try {
				a.setAttribute('href','data:text/plain;charset=utf-8,' + log);
			} catch(e) { // Uh oh... Plan C: Allow the user to copy the data

				console.error('Downloading the log without encodeURIComponent failed due to limited memory. The data will now be printed to the console. Please manually save it as a .csv file to ensure no data is lost.');


				console.warn('Compressed version (JavaScript):');
				console.log('LZString.decompressFromUTF16(\'' + LZString.compressToUTF16(log) + '\');');

				console.warn('Uncompressed version (Copy, then save it as a CSV file manually):');
				console.log(log);

				alert('Uh oh! The download ran out of memory, please see the console for the backup sample log data, which can be manually saved as a CSV file, so that no data is lost.');
			}
		}
		
		a.setAttribute('download', name);
		a.click();
	}
</script>
</html>
